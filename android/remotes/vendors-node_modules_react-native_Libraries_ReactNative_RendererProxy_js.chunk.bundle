(self["webpackChunksataccommodation"] = self["webpackChunksataccommodation"] || []).push([["vendors-node_modules_react-native_Libraries_ReactNative_RendererProxy_js"], {
"./node_modules/ansi-regex/index.js": 
/*!******************************************!*\
  !*** ./node_modules/ansi-regex/index.js ***!
  \******************************************/
(function (module) {
"use strict";

module.exports = (ref)=>{
    var _ref = ref === void 0 ? {} : ref, _ref_onlyFirst = _ref.onlyFirst, onlyFirst = _ref_onlyFirst === void 0 ? false : _ref_onlyFirst;
    var pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
};


}),
"./node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js": 
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js ***!
  \***********************************************************************/
(function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */ function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function(stack, line) {
        var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
        if (parseResult) {
            stack.push(parseResult);
        }
        return stack;
    }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
        return null;
    }
    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
        // throw out eval line/column and use top-most line/column number
        parts[2] = submatch[1]; // url
        parts[3] = submatch[2]; // line
        parts[4] = submatch[3]; // column
    }
    return {
        file: !isNative ? parts[2] : null,
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: isNative ? [
            parts[2]
        ] : [],
        lineNumber: parts[3] ? +parts[3] : null,
        column: parts[4] ? +parts[4] : null
    };
}
var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
        return null;
    }
    return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
    };
}
var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
        return null;
    }
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
        // throw out eval line/column and use top-most line number
        parts[3] = submatch[1];
        parts[4] = submatch[2];
        parts[5] = null; // no column when eval
    }
    return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: parts[2] ? parts[2].split(',') : [],
        lineNumber: parts[4] ? +parts[4] : null,
        column: parts[5] ? +parts[5] : null
    };
}
var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
        return null;
    }
    return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[4],
        column: parts[5] ? +parts[5] : null
    };
}
var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
        return null;
    }
    return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
    };
}
exports.parse = parse;


}),
"./node_modules/whatwg-fetch/dist/fetch.umd.js": 
/*!*****************************************************!*\
  !*** ./node_modules/whatwg-fetch/dist/fetch.umd.js ***!
  \*****************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
(function(global1, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    'use strict';
    /* eslint-disable no-prototype-builtins */ var g = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || // eslint-disable-next-line no-undef
    typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g || {};
    var support = {
        searchParams: 'URLSearchParams' in g,
        iterable: 'Symbol' in g && 'iterator' in Symbol,
        blob: 'FileReader' in g && 'Blob' in g && function() {
            try {
                new Blob();
                return true;
            } catch (e) {
                return false;
            }
        }(),
        formData: 'FormData' in g,
        arrayBuffer: 'ArrayBuffer' in g
    };
    function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
    }
    if (support.arrayBuffer) {
        var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
        ];
        var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
        };
    }
    function normalizeName(name) {
        if (typeof name !== 'string') {
            name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
        }
        return name.toLowerCase();
    }
    function normalizeValue(value) {
        if (typeof value !== 'string') {
            value = String(value);
        }
        return value;
    }
    // Build a destructive iterator for the value list
    function iteratorFor(items) {
        var iterator = {
            next: function() {
                var value = items.shift();
                return {
                    done: value === undefined,
                    value: value
                };
            }
        };
        if (support.iterable) {
            iterator[Symbol.iterator] = function() {
                return iterator;
            };
        }
        return iterator;
    }
    function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
                this.append(name, value);
            }, this);
        } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
                if (header.length != 2) {
                    throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
                }
                this.append(header[0], header[1]);
            }, this);
        } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
            }, this);
        }
    }
    Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var oldValue = this.map[name];
        this.map[name] = oldValue ? oldValue + ', ' + value : value;
    };
    Headers.prototype['delete'] = function(name) {
        delete this.map[normalizeName(name)];
    };
    Headers.prototype.get = function(name) {
        name = normalizeName(name);
        return this.has(name) ? this.map[name] : null;
    };
    Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers.prototype.forEach = function(callback, thisArg) {
        for(var name in this.map){
            if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
            }
        }
    };
    Headers.prototype.keys = function() {
        var items = [];
        this.forEach(function(value, name) {
            items.push(name);
        });
        return iteratorFor(items);
    };
    Headers.prototype.values = function() {
        var items = [];
        this.forEach(function(value) {
            items.push(value);
        });
        return iteratorFor(items);
    };
    Headers.prototype.entries = function() {
        var items = [];
        this.forEach(function(value, name) {
            items.push([
                name,
                value
            ]);
        });
        return iteratorFor(items);
    };
    if (support.iterable) {
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }
    function consumed(body) {
        if (body._noBody) return;
        if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'));
        }
        body.bodyUsed = true;
    }
    function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
            reader.onload = function() {
                resolve(reader.result);
            };
            reader.onerror = function() {
                reject(reader.error);
            };
        });
    }
    function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        reader.readAsArrayBuffer(blob);
        return promise;
    }
    function readBlobAsText(blob) {
        var reader = new FileReader();
        var promise = fileReaderReady(reader);
        var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
        var encoding = match ? match[1] : 'utf-8';
        reader.readAsText(blob, encoding);
        return promise;
    }
    function readArrayBufferAsText(buf) {
        var view = new Uint8Array(buf);
        var chars = new Array(view.length);
        for(var i = 0; i < view.length; i++){
            chars[i] = String.fromCharCode(view[i]);
        }
        return chars.join('');
    }
    function bufferClone(buf) {
        if (buf.slice) {
            return buf.slice(0);
        } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
        }
    }
    function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
            /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */ // eslint-disable-next-line no-self-assign
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
                this._noBody = true;
                this._bodyText = '';
            } else if (typeof body === 'string') {
                this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                // IE 10-11 can't handle a DataView body.
                this._bodyInit = new Blob([
                    this._bodyArrayBuffer
                ]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
            } else {
                this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                    this.headers.set('content-type', 'text/plain;charset=UTF-8');
                } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set('content-type', this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                }
            }
        };
        if (support.blob) {
            this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }
                if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([
                        this._bodyArrayBuffer
                    ]));
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob');
                } else {
                    return Promise.resolve(new Blob([
                        this._bodyText
                    ]));
                }
            };
        }
        this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
                var isConsumed = consumed(this);
                if (isConsumed) {
                    return isConsumed;
                } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                    return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                } else {
                    return Promise.resolve(this._bodyArrayBuffer);
                }
            } else if (support.blob) {
                return this.blob().then(readBlobAsArrayBuffer);
            } else {
                throw new Error('could not read as ArrayBuffer');
            }
        };
        this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }
            if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as text');
            } else {
                return Promise.resolve(this._bodyText);
            }
        };
        if (support.formData) {
            this.formData = function() {
                return this.text().then(decode);
            };
        }
        this.json = function() {
            return this.text().then(JSON.parse);
        };
        return this;
    }
    // HTTP methods whose capitalization should be normalized
    var methods = [
        'CONNECT',
        'DELETE',
        'GET',
        'HEAD',
        'OPTIONS',
        'PATCH',
        'POST',
        'PUT',
        'TRACE'
    ];
    function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return methods.indexOf(upcased) > -1 ? upcased : method;
    }
    function Request(input, options) {
        if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        options = options || {};
        var body = options.body;
        if (input instanceof Request) {
            if (input.bodyUsed) {
                throw new TypeError('Already read');
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
                this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
            }
        } else {
            this.url = String(input);
        }
        this.credentials = options.credentials || this.credentials || 'same-origin';
        if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || 'GET');
        this.mode = options.mode || this.mode || null;
        this.signal = options.signal || this.signal || function() {
            if ('AbortController' in g) {
                var ctrl = new AbortController();
                return ctrl.signal;
            }
        }();
        this.referrer = null;
        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests');
        }
        this._initBody(body);
        if (this.method === 'GET' || this.method === 'HEAD') {
            if (options.cache === 'no-store' || options.cache === 'no-cache') {
                // Search for a '_' parameter in the query string
                var reParamSearch = /([?&])_=[^&]*/;
                if (reParamSearch.test(this.url)) {
                    // If it already exists then set the value with the current time
                    this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                } else {
                    // Otherwise add a new '_' parameter to the end with the current time
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                }
            }
        }
    }
    Request.prototype.clone = function() {
        return new Request(this, {
            body: this._bodyInit
        });
    };
    function decode(body) {
        var form = new FormData();
        body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
                var split = bytes.split('=');
                var name = split.shift().replace(/\+/g, ' ');
                var value = split.join('=').replace(/\+/g, ' ');
                form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
        });
        return form;
    }
    function parseHeaders(rawHeaders) {
        var headers = new Headers();
        // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
        // https://tools.ietf.org/html/rfc7230#section-3.2
        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
        // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
        // https://github.com/github/fetch/issues/748
        // https://github.com/zloirock/core-js/issues/751
        preProcessedHeaders.split('\r').map(function(header) {
            return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
        }).forEach(function(line) {
            var parts = line.split(':');
            var key = parts.shift().trim();
            if (key) {
                var value = parts.join(':').trim();
                try {
                    headers.append(key, value);
                } catch (error) {
                    console.warn('Response ' + error.message);
                }
            }
        });
        return headers;
    }
    Body.call(Request.prototype);
    function Response(bodyInit, options) {
        if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
        }
        if (!options) {
            options = {};
        }
        this.type = 'default';
        this.status = options.status === undefined ? 200 : options.status;
        if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
        }
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
        this.headers = new Headers(options.headers);
        this.url = options.url || '';
        this._initBody(bodyInit);
    }
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
        });
    };
    Response.error = function() {
        var response = new Response(null, {
            status: 200,
            statusText: ''
        });
        response.ok = false;
        response.status = 0;
        response.type = 'error';
        return response;
    };
    var redirectStatuses = [
        301,
        302,
        303,
        307,
        308
    ];
    Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code');
        }
        return new Response(null, {
            status: status,
            headers: {
                location: url
            }
        });
    };
    exports1.DOMException = g.DOMException;
    try {
        new exports1.DOMException();
    } catch (err) {
        exports1.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
        };
        exports1.DOMException.prototype = Object.create(Error.prototype);
        exports1.DOMException.prototype.constructor = exports1.DOMException;
    }
    function fetch(input, init) {
        return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
                return reject(new exports1.DOMException('Aborted', 'AbortError'));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
                xhr.abort();
            }
            xhr.onload = function() {
                var options = {
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                };
                // This check if specifically for when a user fetches a file locally from the file system
                // Only if the status is out of a normal range
                if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
                    options.status = 200;
                } else {
                    options.status = xhr.status;
                }
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                setTimeout(function() {
                    resolve(new Response(body, options));
                }, 0);
            };
            xhr.onerror = function() {
                setTimeout(function() {
                    reject(new TypeError('Network request failed'));
                }, 0);
            };
            xhr.ontimeout = function() {
                setTimeout(function() {
                    reject(new TypeError('Network request timed out'));
                }, 0);
            };
            xhr.onabort = function() {
                setTimeout(function() {
                    reject(new exports1.DOMException('Aborted', 'AbortError'));
                }, 0);
            };
            function fixUrl(url) {
                try {
                    return url === '' && g.location.href ? g.location.href : url;
                } catch (e) {
                    return url;
                }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === 'include') {
                xhr.withCredentials = true;
            } else if (request.credentials === 'omit') {
                xhr.withCredentials = false;
            }
            if ('responseType' in xhr) {
                if (support.blob) {
                    xhr.responseType = 'blob';
                } else if (support.arrayBuffer) {
                    xhr.responseType = 'arraybuffer';
                }
            }
            if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
                var names = [];
                Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    names.push(normalizeName(name));
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                });
                request.headers.forEach(function(value, name) {
                    if (names.indexOf(name) === -1) {
                        xhr.setRequestHeader(name, value);
                    }
                });
            } else {
                request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                });
            }
            if (request.signal) {
                request.signal.addEventListener('abort', abortXhr);
                xhr.onreadystatechange = function() {
                    // DONE (success or failure)
                    if (xhr.readyState === 4) {
                        request.signal.removeEventListener('abort', abortXhr);
                    }
                };
            }
            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        });
    }
    fetch.polyfill = true;
    if (!g.fetch) {
        g.fetch = fetch;
        g.Headers = Headers;
        g.Request = Request;
        g.Response = Response;
    }
    exports1.Headers = Headers;
    exports1.Request = Request;
    exports1.Response = Response;
    exports1.fetch = fetch;
    Object.defineProperty(exports1, '__esModule', {
        value: true
    });
});


}),
"./node_modules/react-native/Libraries/NativeModules/specs/NativeDevSettings.js": 
/*!**************************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/NativeModules/specs/NativeDevSettings.js ***!
  \**************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _export_star = __webpack_require__(/*! @swc/helpers/_/_export_star */ "./node_modules/@swc/helpers/cjs/_export_star.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _NativeDevSettings = /*#__PURE__*/ _interop_require_default._(_export_star._(__webpack_require__(/*! ../../../src/private/specs/modules/NativeDevSettings */ "./node_modules/react-native/src/private/specs/modules/NativeDevSettings.js"), exports));
var _default = _NativeDevSettings.default;


}),
"./node_modules/react-native/Libraries/NativeModules/specs/NativeLogBox.js": 
/*!*********************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/NativeModules/specs/NativeLogBox.js ***!
  \*********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _export_star = __webpack_require__(/*! @swc/helpers/_/_export_star */ "./node_modules/@swc/helpers/cjs/_export_star.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _NativeLogBox = /*#__PURE__*/ _interop_require_default._(_export_star._(__webpack_require__(/*! ../../../src/private/specs/modules/NativeLogBox */ "./node_modules/react-native/src/private/specs/modules/NativeLogBox.js"), exports));
var _default = _NativeLogBox.default;


}),
"./node_modules/react-native/Libraries/NativeModules/specs/NativeSourceCode.js": 
/*!*************************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/NativeModules/specs/NativeSourceCode.js ***!
  \*************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _export_star = __webpack_require__(/*! @swc/helpers/_/_export_star */ "./node_modules/@swc/helpers/cjs/_export_star.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _NativeSourceCode = /*#__PURE__*/ _interop_require_default._(_export_star._(__webpack_require__(/*! ../../../src/private/specs/modules/NativeSourceCode */ "./node_modules/react-native/src/private/specs/modules/NativeSourceCode.js"), exports));
var _default = _NativeSourceCode.default;


}),
"./node_modules/react-native/src/private/specs/modules/NativeDevSettings.js": 
/*!**********************************************************************************!*\
  !*** ./node_modules/react-native/src/private/specs/modules/NativeDevSettings.js ***!
  \**********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _TurboModuleRegistry = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../../Libraries/TurboModule/TurboModuleRegistry */ "./node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"));
var _default = _TurboModuleRegistry.getEnforcing('DevSettings');


}),
"./node_modules/react-native/src/private/specs/modules/NativeLogBox.js": 
/*!*****************************************************************************!*\
  !*** ./node_modules/react-native/src/private/specs/modules/NativeLogBox.js ***!
  \*****************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _TurboModuleRegistry = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../../Libraries/TurboModule/TurboModuleRegistry */ "./node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"));
var _default = _TurboModuleRegistry.get('LogBox');


}),
"./node_modules/react-native/src/private/specs/modules/NativeSourceCode.js": 
/*!*********************************************************************************!*\
  !*** ./node_modules/react-native/src/private/specs/modules/NativeSourceCode.js ***!
  \*********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _TurboModuleRegistry = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../../Libraries/TurboModule/TurboModuleRegistry */ "./node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"));
var NativeModule = _TurboModuleRegistry.getEnforcing('SourceCode');
var constants = null;
var NativeSourceCode = {
    getConstants () {
        if (constants == null) {
            constants = NativeModule.getConstants();
        }
        return constants;
    }
};
var _default = NativeSourceCode;


}),
"./node_modules/react-native/Libraries/Core/Devtools/getDevServer.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Core/Devtools/getDevServer.js ***!
  \***************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _NativeSourceCode = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../NativeModules/specs/NativeSourceCode */ "./node_modules/react-native/Libraries/NativeModules/specs/NativeSourceCode.js"));
var _cachedDevServerURL;
var _cachedFullBundleURL;
var FALLBACK = 'http://localhost:8081/';
/**
 * Many RN development tools rely on the development server (packager) running
 * @return URL to packager with trailing slash
 */ function getDevServer() {
    if (_cachedDevServerURL === undefined) {
        var scriptUrl = _NativeSourceCode.default.getConstants().scriptURL;
        var match = scriptUrl.match(/^https?:\/\/.*?\//);
        _cachedDevServerURL = match ? match[0] : null;
        _cachedFullBundleURL = match ? scriptUrl : null;
    }
    return {
        url: _cachedDevServerURL ?? FALLBACK,
        fullBundleUrl: _cachedFullBundleURL,
        bundleLoadedFromServer: _cachedDevServerURL !== null
    };
}
module.exports = getDevServer;


}),
"./node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js": 
/*!******************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js ***!
  \******************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var parseHermesStack = __webpack_require__(/*! ./parseHermesStack */ "./node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js");
function convertHermesStack(stack) {
    var frames = [];
    for (var entry of stack.entries){
        if (entry.type !== 'FRAME') {
            continue;
        }
        var location = entry.location, functionName = entry.functionName;
        if (location.type === 'NATIVE' || location.type === 'INTERNAL_BYTECODE') {
            continue;
        }
        frames.push({
            methodName: functionName,
            file: location.sourceUrl,
            lineNumber: location.line1Based,
            column: location.type === 'SOURCE' ? location.column1Based - 1 : location.virtualOffset0Based
        });
    }
    return frames;
}
function parseErrorStack(errorStack) {
    if (errorStack == null) {
        return [];
    }
    var stacktraceParser = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.cjs.js");
    var parsedStack = Array.isArray(errorStack) ? errorStack : __webpack_require__.g.HermesInternal ? convertHermesStack(parseHermesStack(errorStack)) : stacktraceParser.parse(errorStack).map((frame)=>_object_spread_props._(_object_spread._({}, frame), {
            column: frame.column != null ? frame.column - 1 : null
        }));
    return parsedStack;
}
module.exports = parseErrorStack;


}),
"./node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js": 
/*!*******************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Core/Devtools/parseHermesStack.js ***!
  \*******************************************************************************/
(function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
// Capturing groups:
// 1. function name
// 2. is this a native stack frame?
// 3. is this a bytecode address or a source location?
// 4. source URL (filename)
// 5. line number (1 based)
// 6. column number (1 based) or virtual offset (0 based)
var RE_FRAME = /^ {4}at (.+?)(?: \((native)\)?| \((address at )?(.*?):(\d+):(\d+)\))$/;
// Capturing groups:
// 1. count of skipped frames
var RE_SKIPPED = /^ {4}... skipping (\d+) frames$/;
var RE_COMPONENT_NO_STACK = /^ {4}at .*$/;
function isInternalBytecodeSourceUrl(sourceUrl) {
    // See https://github.com/facebook/hermes/blob/3332fa020cae0bab751f648db7c94e1d687eeec7/lib/VM/Runtime.cpp#L1100
    return sourceUrl === 'InternalBytecode.js';
}
function parseLine(line) {
    var asFrame = line.match(RE_FRAME);
    if (asFrame) {
        return {
            type: 'FRAME',
            functionName: asFrame[1],
            location: asFrame[2] === 'native' ? {
                type: 'NATIVE'
            } : asFrame[3] === 'address at ' ? isInternalBytecodeSourceUrl(asFrame[4]) ? {
                type: 'INTERNAL_BYTECODE',
                sourceUrl: asFrame[4],
                line1Based: Number.parseInt(asFrame[5], 10),
                virtualOffset0Based: Number.parseInt(asFrame[6], 10)
            } : {
                type: 'BYTECODE',
                sourceUrl: asFrame[4],
                line1Based: Number.parseInt(asFrame[5], 10),
                virtualOffset0Based: Number.parseInt(asFrame[6], 10)
            } : {
                type: 'SOURCE',
                sourceUrl: asFrame[4],
                line1Based: Number.parseInt(asFrame[5], 10),
                column1Based: Number.parseInt(asFrame[6], 10)
            }
        };
    }
    var asSkipped = line.match(RE_SKIPPED);
    if (asSkipped) {
        return {
            type: 'SKIPPED',
            count: Number.parseInt(asSkipped[1], 10)
        };
    }
}
module.exports = function parseHermesStack(stack) {
    var lines = stack.split(/\n/);
    var entries = [];
    var lastMessageLine = -1;
    for(var i = 0; i < lines.length; ++i){
        var line = lines[i];
        if (!line) {
            continue;
        }
        var entry = parseLine(line);
        if (entry) {
            entries.push(entry);
            continue;
        }
        if (RE_COMPONENT_NO_STACK.test(line)) {
            continue;
        }
        // No match - we're still in the message
        lastMessageLine = i;
        entries = [];
    }
    var message = lines.slice(0, lastMessageLine + 1).join('\n');
    return {
        message,
        entries
    };
};


}),
"./node_modules/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js": 
/*!************************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js ***!
  \************************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ "./node_modules/@swc/helpers/cjs/_async_to_generator.cjs");
var getDevServer = __webpack_require__(/*! ./getDevServer */ "./node_modules/react-native/Libraries/Core/Devtools/getDevServer.js");
function symbolicateStackTrace(stack, extraData) {
    return _async_to_generator._(function*() {
        var devServer = getDevServer();
        if (!devServer.bundleLoadedFromServer) {
            throw new Error('Bundle was not loaded from Metro.');
        }
        // Lazy-load `fetch` until the first symbolication call to avoid circular requires.
        var fetch = __webpack_require__.g.fetch ?? __webpack_require__(/*! ../../Network/fetch */ "./node_modules/react-native/Libraries/Network/fetch.js");
        var response = yield fetch(devServer.url + 'symbolicate', {
            method: 'POST',
            body: JSON.stringify({
                stack,
                extraData
            })
        });
        return yield response.json();
    })();
}
module.exports = symbolicateStackTrace;


}),
"./node_modules/react-native/Libraries/Core/ExceptionsManager.js": 
/*!***********************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Core/ExceptionsManager.js ***!
  \***********************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var _wrap_native_super = __webpack_require__(/*! @swc/helpers/_/_wrap_native_super */ "./node_modules/@swc/helpers/cjs/_wrap_native_super.cjs");
var SyntheticError = /*#__PURE__*/ function(Error1) {
    _inherits._(SyntheticError, Error1);
    function SyntheticError() {
        _class_call_check._(this, SyntheticError);
        var _this;
        _this = _call_super._(this, SyntheticError, arguments), _this.name = '';
        return _this;
    }
    return SyntheticError;
}(_wrap_native_super._(Error));
var userExceptionDecorator;
var inUserExceptionDecorator = false;
// This string is used to decorate an ExtendedError with extra data in select usecases.
// Note that data passed using this method should be strictly contained,
// as data that's not serializable/too large may cause issues with passing the error to the native code.
// TODO(T204185517): We should use a Symbol for this, but jsi through jsc doesn't support it yet.
var decoratedExtraDataKey = 'RN$ErrorExtraDataKey';
/**
 * Allows the app to add information to the exception report before it is sent
 * to native. This API is not final.
 */ function unstable_setExceptionDecorator(exceptionDecorator) {
    userExceptionDecorator = exceptionDecorator;
}
function preprocessException(data) {
    if (userExceptionDecorator && !inUserExceptionDecorator) {
        inUserExceptionDecorator = true;
        try {
            return userExceptionDecorator(data);
        } catch  {
        // Fall through
        } finally{
            inUserExceptionDecorator = false;
        }
    }
    return data;
}
/**
 * Handles the developer-visible aspect of errors and exceptions
 */ var exceptionID = 0;
function reportException(e, isFatal, reportToConsole) {
    var parseErrorStack = __webpack_require__(/*! ./Devtools/parseErrorStack */ "./node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js");
    var stack = parseErrorStack(e === null || e === void 0 ? void 0 : e.stack);
    var currentExceptionID = ++exceptionID;
    var originalMessage = e.message || '';
    var message = originalMessage;
    if (e.componentStack != null) {
        message += `\n\nThis error is located at:${e.componentStack}`;
    }
    var namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;
    if (!message.startsWith(namePrefix)) {
        message = namePrefix + message;
    }
    message = e.jsEngine == null ? message : `${message}, js engine: ${e.jsEngine}`;
    // $FlowFixMe[unclear-type]
    var extraData = _object_spread_props._(_object_spread._({}, e[decoratedExtraDataKey]), {
        jsEngine: e.jsEngine,
        rawStack: e.stack
    });
    if (e.cause != null && typeof e.cause === 'object') {
        extraData.stackSymbols = e.cause.stackSymbols;
        extraData.stackReturnAddresses = e.cause.stackReturnAddresses;
        extraData.stackElements = e.cause.stackElements;
    }
    var data = preprocessException({
        message,
        originalMessage: message === originalMessage ? null : originalMessage,
        name: e.name == null || e.name === '' ? null : e.name,
        componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,
        stack,
        id: currentExceptionID,
        isFatal,
        extraData
    });
    if (reportToConsole) {
        // we feed back into console.error, to make sure any methods that are
        // monkey patched on top of console.error are called when coming from
        // handleException
        console.error(data.message);
    }
    if (true) {
        var LogBox = (__webpack_require__(/*! ../LogBox/LogBox */ "./node_modules/react-native/Libraries/LogBox/LogBox.js")/* ["default"] */["default"]);
        LogBox.addException(_object_spread_props._(_object_spread._({}, data), {
            isComponentError: !!e.isComponentError
        }));
    } else { var _global_RN$hasHandledFatalException, _global_RN$notifyOfFatalException, _global1, _global, NativeExceptionsManager }
}
// If we trigger console.error _from_ handleException,
// we do want to make sure that console.error doesn't trigger error reporting again
var inExceptionHandler = false;
/**
 * Logs exceptions to the (native) console and displays them
 */ function handleException(e, isFatal) {
    // TODO(T196834299): We should really use a c++ turbomodule for this
    var reportToConsole = true;
    if (!__webpack_require__.g.RN$handleException || !__webpack_require__.g.RN$handleException(e, isFatal, reportToConsole)) {
        var error;
        if (e instanceof Error) {
            error = e;
        } else {
            // Workaround for reporting errors caused by `throw 'some string'`
            // Unfortunately there is no way to figure out the stacktrace in this
            // case, so if you ended up here trying to trace an error, look for
            // `throw '<error message>'` somewhere in your codebase.
            error = new SyntheticError(e);
        }
        try {
            inExceptionHandler = true;
            /* $FlowFixMe[class-object-subtyping] added when improving typing for this
       * parameters */ // $FlowFixMe[incompatible-call]
            reportException(error, isFatal, reportToConsole);
        } finally{
            inExceptionHandler = false;
        }
    }
}
/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
 * LTI update could not be added via codemod */ function reactConsoleErrorHandler(...args) {
    var // bubble up to any original handlers
    _console;
    var _global_RN$inExceptionHandler, _global;
    (_console = console)._errorOriginal.apply(_console, _to_consumable_array._(args));
    if (!console.reportErrorsAsExceptions) {
        return;
    }
    if (inExceptionHandler || ((_global_RN$inExceptionHandler = (_global = __webpack_require__.g).RN$inExceptionHandler) === null || _global_RN$inExceptionHandler === void 0 ? void 0 : _global_RN$inExceptionHandler.call(_global))) {
        // The fundamental trick here is that are multiple entry point to logging errors:
        // (see D19743075 for more background)
        //
        // 1. An uncaught exception being caught by the global handler
        // 2. An error being logged throw console.error
        //
        // However, console.error is monkey patched multiple times: by this module, and by the
        // DevTools setup that sends messages to Metro.
        // The patching order cannot be relied upon.
        //
        // So, some scenarios that are handled by this flag:
        //
        // Logging an error:
        // 1. console.error called from user code
        // 2. (possibly) arrives _first_ at DevTool handler, send to Metro
        // 3. Bubbles to here
        // 4. goes into report Exception.
        // 5. should not trigger console.error again, to avoid looping / logging twice
        // 6. should still bubble up to original console
        //    (which might either be console.log, or the DevTools handler in case it patched _earlier_ and (2) didn't happen)
        //
        // Throwing an uncaught exception:
        // 1. exception thrown
        // 2. picked up by handleException
        // 3. should be sent to console.error (not console._errorOriginal, as DevTools might have patched _later_ and it needs to send it to Metro)
        // 4. that _might_ bubble again to the `reactConsoleErrorHandle` defined here
        //    -> should not handle exception _again_, to avoid looping / showing twice (this code branch)
        // 5. should still bubble up to original console (which might either be console.log, or the DevTools handler in case that one patched _earlier_)
        return;
    }
    var error;
    var firstArg = args[0];
    if (firstArg === null || firstArg === void 0 ? void 0 : firstArg.stack) {
        // reportException will console.error this with high enough fidelity.
        error = firstArg;
    } else {
        var stringifySafe = (__webpack_require__(/*! ../Utilities/stringifySafe */ "./node_modules/react-native/Libraries/Utilities/stringifySafe.js")/* ["default"] */["default"]);
        if (typeof firstArg === 'string' && firstArg.startsWith('Warning: ')) {
            // React warnings use console.error so that a stack trace is shown, but
            // we don't (currently) want these to show a redbox
            // (Note: Logic duplicated in polyfills/console.js.)
            return;
        }
        var message = args.map((arg)=>typeof arg === 'string' ? arg : stringifySafe(arg)).join(' ');
        error = new SyntheticError(message);
        error.name = 'console.error';
    }
    var isFatal = false;
    var reportToConsole = false;
    if (!__webpack_require__.g.RN$handleException || !__webpack_require__.g.RN$handleException(error, isFatal, reportToConsole)) {
        reportException(/* $FlowFixMe[class-object-subtyping] added when improving typing for this
       * parameters */ // $FlowFixMe[incompatible-call]
        error, isFatal, reportToConsole);
    }
}
/**
 * Shows a redbox with stacktrace for all console.error messages.  Disable by
 * setting `console.reportErrorsAsExceptions = false;` in your app.
 */ function installConsoleErrorReporter() {
    // Enable reportErrorsAsExceptions
    if (console._errorOriginal) {
        return; // already installed
    }
    // Flow doesn't like it when you set arbitrary values on a global object
    console._errorOriginal = console.error.bind(console);
    console.error = reactConsoleErrorHandler;
    if (console.reportErrorsAsExceptions === undefined) {
        // Individual apps can disable this
        // Flow doesn't like it when you set arbitrary values on a global object
        console.reportErrorsAsExceptions = true;
    }
}
module.exports = {
    decoratedExtraDataKey,
    handleException,
    installConsoleErrorReporter,
    SyntheticError,
    unstable_setExceptionDecorator
};


}),
"./node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js": 
/*!***********************************************************************!*\
  !*** ./node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js ***!
  \***********************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get addException () {
        return addException;
    },
    get addIgnorePatterns () {
        return addIgnorePatterns;
    },
    get addLog () {
        return addLog;
    },
    get checkWarningFilter () {
        return checkWarningFilter;
    },
    get clear () {
        return clear;
    },
    get clearErrors () {
        return clearErrors;
    },
    get clearWarnings () {
        return clearWarnings;
    },
    get dismiss () {
        return dismiss;
    },
    get getAppInfo () {
        return getAppInfo;
    },
    get getIgnorePatterns () {
        return getIgnorePatterns;
    },
    get isDisabled () {
        return isDisabled;
    },
    get isLogBoxErrorMessage () {
        return isLogBoxErrorMessage;
    },
    get isMessageIgnored () {
        return isMessageIgnored;
    },
    get observe () {
        return observe;
    },
    get reportLogBoxError () {
        return reportLogBoxError;
    },
    get retrySymbolicateLogNow () {
        return retrySymbolicateLogNow;
    },
    get setAppInfo () {
        return setAppInfo;
    },
    get setDisabled () {
        return setDisabled;
    },
    get setSelectedLog () {
        return setSelectedLog;
    },
    get setWarningFilter () {
        return setWarningFilter;
    },
    get symbolicateLogLazy () {
        return symbolicateLogLazy;
    },
    get symbolicateLogNow () {
        return symbolicateLogNow;
    },
    get withSubscription () {
        return withSubscription;
    }
});
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _FuseboxSessionObserver = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../../src/private/debugging/FuseboxSessionObserver */ "./node_modules/react-native/src/private/debugging/FuseboxSessionObserver.js"));
var _parseErrorStack = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../Core/Devtools/parseErrorStack */ "./node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js"));
var _NativeDevSettings = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../NativeModules/specs/NativeDevSettings */ "./node_modules/react-native/Libraries/NativeModules/specs/NativeDevSettings.js"));
var _NativeLogBox = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../NativeModules/specs/NativeLogBox */ "./node_modules/react-native/Libraries/NativeModules/specs/NativeLogBox.js"));
var _LogBoxLog = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./LogBoxLog */ "./node_modules/react-native/Libraries/LogBox/Data/LogBoxLog.js"));
var _parseLogBoxLog = __webpack_require__(/*! ./parseLogBoxLog */ "./node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e11"));
var observers = new Set();
var ignorePatterns = new Set();
var appInfo = null;
var logs = new Set();
var updateTimeout = null;
var _isDisabled = false;
var _selectedIndex = -1;
var hasShownFuseboxWarningsMigrationMessage = false;
var hostTargetSessionObserverSubscription = null;
var warningFilter = function(format) {
    return {
        finalFormat: format,
        forceDialogImmediately: false,
        suppressDialog_LEGACY: false,
        suppressCompletely: false,
        monitorEvent: 'warning_unhandled',
        monitorListVersion: 0,
        monitorSampleRate: 1
    };
};
var LOGBOX_ERROR_MESSAGE = 'An error was thrown when attempting to render log messages via LogBox.';
function getNextState() {
    return {
        logs,
        isDisabled: _isDisabled,
        selectedLogIndex: _selectedIndex
    };
}
function reportLogBoxError(error, componentStack) {
    var ExceptionsManager = __webpack_require__(/*! ../../Core/ExceptionsManager */ "./node_modules/react-native/Libraries/Core/ExceptionsManager.js");
    error.message = `${LOGBOX_ERROR_MESSAGE}\n\n${error.message}`;
    if (componentStack != null) {
        error.componentStack = componentStack;
    }
    ExceptionsManager.handleException(error, /* isFatal */ true);
}
function isLogBoxErrorMessage(message) {
    return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);
}
function isMessageIgnored(message) {
    for (var pattern of ignorePatterns){
        if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {
            return true;
        }
    }
    return false;
}
function handleUpdate() {
    if (updateTimeout == null) {
        updateTimeout = setImmediate(()=>{
            updateTimeout = null;
            var nextState = getNextState();
            observers.forEach((ref)=>{
                var observer = ref.observer;
                return observer(nextState);
            });
        });
    }
}
function appendNewLog(newLog) {
    // Don't want store these logs because they trigger a
    // state update when we add them to the store.
    if (isMessageIgnored(newLog.message.content)) {
        return;
    }
    // If the next log has the same category as the previous one
    // then roll it up into the last log in the list by incrementing
    // the count (similar to how Chrome does it).
    var lastLog = Array.from(logs).pop();
    if (lastLog && lastLog.category === newLog.category) {
        lastLog.incrementCount();
        handleUpdate();
        return;
    }
    if (newLog.level === 'fatal') {
        // If possible, to avoid jank, we don't want to open the error before
        // it's symbolicated. To do that, we optimistically wait for
        // symbolication for up to a second before adding the log.
        var OPTIMISTIC_WAIT_TIME = 1000;
        var addPendingLog = ()=>{
            logs.add(newLog);
            if (_selectedIndex < 0) {
                setSelectedLog(logs.size - 1);
            } else {
                handleUpdate();
            }
            addPendingLog = null;
        };
        var optimisticTimeout = setTimeout(()=>{
            if (addPendingLog) {
                addPendingLog();
            }
        }, OPTIMISTIC_WAIT_TIME);
        newLog.symbolicate((status)=>{
            if (addPendingLog && status !== 'PENDING') {
                addPendingLog();
                clearTimeout(optimisticTimeout);
            } else if (status !== 'PENDING') {
                // The log has already been added but we need to trigger a render.
                handleUpdate();
            }
        });
    } else if (newLog.level === 'syntax') {
        logs.add(newLog);
        setSelectedLog(logs.size - 1);
    } else {
        logs.add(newLog);
        handleUpdate();
    }
}
function addLog(log) {
    if (hostTargetSessionObserverSubscription == null) {
        hostTargetSessionObserverSubscription = _FuseboxSessionObserver.default.subscribe((hasActiveSession)=>{
            if (hasActiveSession) {
                clearWarnings();
            } else {
                // Reset the flag so that we can show the message again if new warning was emitted
                hasShownFuseboxWarningsMigrationMessage = false;
            }
        });
    }
    // If Host has Fusebox support
    if (log.level === 'warn' && __webpack_require__.g.__FUSEBOX_HAS_FULL_CONSOLE_SUPPORT__) {
        // And there is no active debugging session
        if (!_FuseboxSessionObserver.default.hasActiveSession()) {
            showFuseboxWarningsMigrationMessageOnce();
        }
        // Don't show LogBox warnings when Host has active debugging session
        return;
    }
    var errorForStackTrace = new Error();
    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setImmediate(()=>{
        try {
            var stack = (0, _parseErrorStack.default)(log.stack ?? (errorForStackTrace === null || errorForStackTrace === void 0 ? void 0 : errorForStackTrace.stack));
            appendNewLog(new _LogBoxLog.default({
                level: log.level,
                message: log.message,
                isComponentError: false,
                stack,
                category: log.category,
                componentStack: log.componentStack,
                componentStackType: log.componentStackType || 'legacy'
            }));
        } catch (error) {
            reportLogBoxError(error);
        }
    });
}
function addException(error) {
    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setImmediate(()=>{
        try {
            appendNewLog(new _LogBoxLog.default((0, _parseLogBoxLog.parseLogBoxException)(error)));
        } catch (loggingError) {
            reportLogBoxError(loggingError);
        }
    });
}
function symbolicateLogNow(log) {
    log.symbolicate(()=>{
        handleUpdate();
    });
}
function retrySymbolicateLogNow(log) {
    log.retrySymbolicate(()=>{
        handleUpdate();
    });
}
function symbolicateLogLazy(log) {
    log.symbolicate();
}
function clear() {
    if (logs.size > 0) {
        logs = new Set();
        setSelectedLog(-1);
    }
}
function setSelectedLog(proposedNewIndex) {
    var oldIndex = _selectedIndex;
    var newIndex = proposedNewIndex;
    var logArray = Array.from(logs);
    var index = logArray.length - 1;
    while(index >= 0){
        // The latest syntax error is selected and displayed before all other logs.
        if (logArray[index].level === 'syntax') {
            newIndex = index;
            break;
        }
        index -= 1;
    }
    _selectedIndex = newIndex;
    handleUpdate();
    if (_NativeLogBox.default) {
        setTimeout(()=>{
            if (oldIndex < 0 && newIndex >= 0) {
                _NativeLogBox.default.show();
            } else if (oldIndex >= 0 && newIndex < 0) {
                _NativeLogBox.default.hide();
            }
        }, 0);
    }
}
function clearWarnings() {
    var newLogs = Array.from(logs).filter((log)=>log.level !== 'warn');
    if (newLogs.length !== logs.size) {
        logs = new Set(newLogs);
        setSelectedLog(-1);
        handleUpdate();
    }
}
function clearErrors() {
    var newLogs = Array.from(logs).filter((log)=>log.level !== 'error' && log.level !== 'fatal');
    if (newLogs.length !== logs.size) {
        logs = new Set(newLogs);
        setSelectedLog(-1);
    }
}
function dismiss(log) {
    if (logs.has(log)) {
        logs.delete(log);
        handleUpdate();
    }
}
function setWarningFilter(filter) {
    warningFilter = filter;
}
function setAppInfo(info) {
    appInfo = info;
}
function getAppInfo() {
    return appInfo != null ? appInfo() : null;
}
function checkWarningFilter(format) {
    return warningFilter(format);
}
function getIgnorePatterns() {
    return Array.from(ignorePatterns);
}
function addIgnorePatterns(patterns) {
    var existingSize = ignorePatterns.size;
    // The same pattern may be added multiple times, but adding a new pattern
    // can be expensive so let's find only the ones that are new.
    patterns.forEach((pattern)=>{
        if (pattern instanceof RegExp) {
            for (var existingPattern of ignorePatterns){
                if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {
                    return;
                }
            }
            ignorePatterns.add(pattern);
        }
        ignorePatterns.add(pattern);
    });
    if (ignorePatterns.size === existingSize) {
        return;
    }
    // We need to recheck all of the existing logs.
    // This allows adding an ignore pattern anywhere in the codebase.
    // Without this, if you ignore a pattern after the a log is created,
    // then we would keep showing the log.
    logs = new Set(Array.from(logs).filter((log)=>!isMessageIgnored(log.message.content)));
    handleUpdate();
}
function setDisabled(value) {
    if (value === _isDisabled) {
        return;
    }
    _isDisabled = value;
    handleUpdate();
}
function isDisabled() {
    return _isDisabled;
}
function observe(observer) {
    var subscription = {
        observer
    };
    observers.add(subscription);
    observer(getNextState());
    return {
        unsubscribe () {
            observers.delete(subscription);
        }
    };
}
function withSubscription(WrappedComponent) {
    var LogBoxStateSubscription = /*#__PURE__*/ function(_React_Component) {
        "use strict";
        _inherits._(LogBoxStateSubscription, _React_Component);
        function LogBoxStateSubscription() {
            _class_call_check._(this, LogBoxStateSubscription);
            var _this;
            _this = _call_super._(this, LogBoxStateSubscription, arguments), _this.state = {
                logs: new Set(),
                isDisabled: false,
                hasError: false,
                selectedLogIndex: -1
            };
            return _this;
        }
        _create_class._(LogBoxStateSubscription, [
            {
                key: "componentDidCatch",
                value: function componentDidCatch(err, errorInfo) {
                    /* $FlowFixMe[class-object-subtyping] added when improving typing for
       * this parameters */ // $FlowFixMe[incompatible-call]
                    reportLogBoxError(err, errorInfo.componentStack);
                }
            },
            {
                key: "render",
                value: function render() {
                    if (this.state.hasError) {
                        // This happens when the component failed to render, in which case we delegate to the native redbox.
                        // We can't show anyback fallback UI here, because the error may be with <View> or <Text>.
                        return null;
                    }
                    return /*#__PURE__*/ (0, _jsxruntime.jsx)(WrappedComponent, {
                        logs: Array.from(this.state.logs),
                        isDisabled: this.state.isDisabled,
                        selectedLogIndex: this.state.selectedLogIndex
                    });
                }
            },
            {
                key: "componentDidMount",
                value: function componentDidMount() {
                    this._subscription = observe((data)=>{
                        this.setState(data);
                    });
                }
            },
            {
                key: "componentWillUnmount",
                value: function componentWillUnmount() {
                    if (this._subscription != null) {
                        this._subscription.unsubscribe();
                    }
                }
            }
        ], [
            {
                key: "getDerivedStateFromError",
                value: function getDerivedStateFromError() {
                    return {
                        hasError: true
                    };
                }
            }
        ]);
        return LogBoxStateSubscription;
    }(_react.Component);
    return LogBoxStateSubscription;
}
function showFuseboxWarningsMigrationMessageOnce() {
    if (hasShownFuseboxWarningsMigrationMessage) {
        return;
    }
    hasShownFuseboxWarningsMigrationMessage = true;
    appendNewLog(new _LogBoxLog.default({
        level: 'warn',
        message: {
            content: 'Open debugger to view warnings.',
            substitutions: []
        },
        isComponentError: false,
        stack: [],
        category: 'fusebox-warnings-migration',
        componentStack: [],
        onNotificationPress: ()=>{
            if (_NativeDevSettings.default.openDebugger) {
                _NativeDevSettings.default.openDebugger();
            }
        }
    }));
}


}),
"./node_modules/react-native/Libraries/LogBox/Data/LogBoxLog.js": 
/*!**********************************************************************!*\
  !*** ./node_modules/react-native/Libraries/LogBox/Data/LogBoxLog.js ***!
  \**********************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _LogBoxSymbolication = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./LogBoxSymbolication */ "./node_modules/react-native/Libraries/LogBox/Data/LogBoxSymbolication.js"));
// TODO: once component stacks are fully supported, we can refactor
// ComponentStack to just be Stack and remove these conversions fns.
function convertComponentStateToStack(componentStack) {
    return componentStack.map((frame)=>{
        var _frame_location, _frame_location1;
        return {
            column: frame === null || frame === void 0 ? void 0 : (_frame_location = frame.location) === null || _frame_location === void 0 ? void 0 : _frame_location.column,
            file: frame.fileName,
            lineNumber: frame === null || frame === void 0 ? void 0 : (_frame_location1 = frame.location) === null || _frame_location1 === void 0 ? void 0 : _frame_location1.row,
            methodName: frame.content,
            collapse: false
        };
    });
}
function convertStackToComponentStack(stack) {
    var componentStack = [];
    for(var i = 0; i < stack.length; i++){
        var frame = stack[i];
        // NOTE: Skip stack frames missing location.
        if (frame.lineNumber != null && frame.column != null) {
            componentStack.push({
                fileName: (frame === null || frame === void 0 ? void 0 : frame.file) || '',
                location: {
                    row: frame.lineNumber,
                    column: frame.column
                },
                content: frame.methodName,
                collapse: false
            });
        }
    }
    return componentStack;
}
var LogBoxLog = /*#__PURE__*/ function() {
    "use strict";
    function LogBoxLog(data) {
        _class_call_check._(this, LogBoxLog);
        this.symbolicated = {
            error: null,
            stack: null,
            status: 'NONE'
        };
        this.symbolicatedComponentStack = {
            error: null,
            componentStack: null,
            status: 'NONE'
        };
        this.level = data.level;
        this.type = data.type;
        this.message = data.message;
        this.stack = data.stack;
        this.category = data.category;
        this.componentStack = data.componentStack;
        this.componentStackType = data.componentStackType || 'legacy';
        this.codeFrame = data.codeFrame;
        this.isComponentError = data.isComponentError;
        this.extraData = data.extraData;
        this.count = 1;
        this.onNotificationPress = data.onNotificationPress;
    }
    _create_class._(LogBoxLog, [
        {
            key: "incrementCount",
            value: function incrementCount() {
                this.count += 1;
            }
        },
        {
            key: "getAvailableStack",
            value: function getAvailableStack() {
                return this.symbolicated.status === 'COMPLETE' ? this.symbolicated.stack : this.stack;
            }
        },
        {
            key: "getAvailableComponentStack",
            value: function getAvailableComponentStack() {
                if (this.componentStackType === 'legacy') {
                    return this.componentStack;
                }
                return this.symbolicatedComponentStack.status === 'COMPLETE' ? this.symbolicatedComponentStack.componentStack : this.componentStack;
            }
        },
        {
            key: "retrySymbolicate",
            value: function retrySymbolicate(callback) {
                if (this.symbolicated.status !== 'COMPLETE') {
                    _LogBoxSymbolication.deleteStack(this.stack);
                    this.handleSymbolicate(callback);
                }
            }
        },
        {
            key: "symbolicate",
            value: function symbolicate(callback) {
                if (this.symbolicated.status === 'NONE') {
                    this.handleSymbolicate(callback);
                }
            }
        },
        {
            key: "handleSymbolicate",
            value: function handleSymbolicate(callback) {
                if (this.symbolicated.status !== 'PENDING') {
                    this.updateStatus(null, null, null, callback);
                    _LogBoxSymbolication.symbolicate(this.stack, this.extraData).then((data)=>{
                        this.updateStatus(null, data === null || data === void 0 ? void 0 : data.stack, data === null || data === void 0 ? void 0 : data.codeFrame, callback);
                    }, (error)=>{
                        this.updateStatus(error, null, null, callback);
                    });
                    if (this.componentStack != null && this.componentStackType === 'stack') {
                        this.updateComponentStackStatus(null, null, null, callback);
                        var componentStackFrames = convertComponentStateToStack(this.componentStack);
                        _LogBoxSymbolication.symbolicate(componentStackFrames, []).then((data)=>{
                            this.updateComponentStackStatus(null, convertStackToComponentStack(data.stack), null, callback);
                        }, (error)=>{
                            this.updateComponentStackStatus(error, null, null, callback);
                        });
                    }
                }
            }
        },
        {
            key: "updateStatus",
            value: function updateStatus(error, stack, codeFrame, callback) {
                var lastStatus = this.symbolicated.status;
                if (error != null) {
                    this.symbolicated = {
                        error,
                        stack: null,
                        status: 'FAILED'
                    };
                } else if (stack != null) {
                    if (codeFrame) {
                        this.codeFrame = codeFrame;
                    }
                    this.symbolicated = {
                        error: null,
                        stack,
                        status: 'COMPLETE'
                    };
                } else {
                    this.symbolicated = {
                        error: null,
                        stack: null,
                        status: 'PENDING'
                    };
                }
                if (callback && lastStatus !== this.symbolicated.status) {
                    callback(this.symbolicated.status);
                }
            }
        },
        {
            key: "updateComponentStackStatus",
            value: function updateComponentStackStatus(error, componentStack, codeFrame, callback) {
                var lastStatus = this.symbolicatedComponentStack.status;
                if (error != null) {
                    this.symbolicatedComponentStack = {
                        error,
                        componentStack: null,
                        status: 'FAILED'
                    };
                } else if (componentStack != null) {
                    this.symbolicatedComponentStack = {
                        error: null,
                        componentStack,
                        status: 'COMPLETE'
                    };
                } else {
                    this.symbolicatedComponentStack = {
                        error: null,
                        componentStack: null,
                        status: 'PENDING'
                    };
                }
                if (callback && lastStatus !== this.symbolicatedComponentStack.status) {
                    callback(this.symbolicatedComponentStack.status);
                }
            }
        }
    ]);
    return LogBoxLog;
}();
var _default = LogBoxLog;


}),
"./node_modules/react-native/Libraries/LogBox/Data/LogBoxSymbolication.js": 
/*!********************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/LogBox/Data/LogBoxSymbolication.js ***!
  \********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get deleteStack () {
        return deleteStack;
    },
    get symbolicate () {
        return symbolicate;
    }
});
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _symbolicateStackTrace = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../Core/Devtools/symbolicateStackTrace */ "./node_modules/react-native/Libraries/Core/Devtools/symbolicateStackTrace.js"));
var cache = new Map();
/**
 * Sanitize because sometimes, `symbolicateStackTrace` gives us invalid values.
 */ var sanitize = (ref)=>{
    var maybeStack = ref.stack, codeFrame = ref.codeFrame;
    if (!Array.isArray(maybeStack)) {
        throw new Error('Expected stack to be an array.');
    }
    var stack = [];
    for (var maybeFrame of maybeStack){
        var collapse = false;
        if ('collapse' in maybeFrame) {
            if (typeof maybeFrame.collapse !== 'boolean') {
                throw new Error('Expected stack frame `collapse` to be a boolean.');
            }
            collapse = maybeFrame.collapse;
        }
        stack.push({
            column: maybeFrame.column,
            file: maybeFrame.file,
            lineNumber: maybeFrame.lineNumber,
            methodName: maybeFrame.methodName,
            collapse
        });
    }
    return {
        stack,
        codeFrame
    };
};
function deleteStack(stack) {
    cache.delete(stack);
}
function symbolicate(stack, extraData) {
    var promise = cache.get(stack);
    if (promise == null) {
        promise = (0, _symbolicateStackTrace.default)(stack, extraData).then(sanitize);
        cache.set(stack, promise);
    }
    return promise;
}


}),
"./node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js": 
/*!***************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js ***!
  \***************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get hasComponentStack () {
        return hasComponentStack;
    },
    get parseComponentStack () {
        return parseComponentStack;
    },
    get parseInterpolation () {
        return parseInterpolation;
    },
    get parseLogBoxException () {
        return parseLogBoxException;
    },
    get parseLogBoxLog () {
        return parseLogBoxLog;
    },
    get withoutANSIColorStyles () {
        return withoutANSIColorStyles;
    }
});
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var _parseErrorStack = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../Core/Devtools/parseErrorStack */ "./node_modules/react-native/Libraries/Core/Devtools/parseErrorStack.js"));
var _UTFSequence = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../UTFSequence */ "./node_modules/react-native/Libraries/UTFSequence.js"));
var _stringifySafe = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../Utilities/stringifySafe */ "./node_modules/react-native/Libraries/Utilities/stringifySafe.js"));
var _ansiregex = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ansi-regex */ "./node_modules/ansi-regex/index.js"));
var ANSI_REGEX = (0, _ansiregex.default)().source;
var RE_TRANSFORM_ERROR = /^TransformError /;
var RE_COMPONENT_STACK_LINE = /\n {4}(in|at) /;
var RE_COMPONENT_STACK_LINE_GLOBAL = /\n {4}(in|at) /g;
var RE_COMPONENT_STACK_LINE_OLD = / {4}in/;
var RE_COMPONENT_STACK_LINE_NEW = / {4}at/;
var RE_COMPONENT_STACK_LINE_STACK_FRAME = /@.*\n/;
// "TransformError " (Optional) and either "SyntaxError: " or "ReferenceError: "
// Capturing groups:
// 1: error message
// 2: file path
// 3: line number
// 4: column number
// \n\n
// 5: code frame
var RE_BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/;
// Capturing groups:
// 1: component name
// "at"
// 2: file path including extension
// 3: line number
var RE_COMPONENT_STACK_WITH_SOURCE = /(.*) \(at (.*\.(?:js|jsx|ts|tsx)):([\d]+)\)/;
// Capturing groups:
// 1: component name
// "at"
// 2: parent component name
var RE_COMPONENT_STACK_NO_SOURCE = /(.*) \(created by .*\)/;
// Capturing groups:
// - non-capturing "TransformError " (optional)
// - non-capturing Error message
// 1: file path
// 2: file name
// 3: error message
// 4: code frame, which includes code snippet indicators or terminal escape sequences for formatting.
var RE_BABEL_CODE_FRAME_ERROR_FORMAT = // eslint-disable-next-line no-control-regex
RegExp("^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)", "u");
// Capturing groups:
// - non-capturing "InternalError Metro has encountered an error:"
// 1: error title
// 2: error message
// 3: file path
// 4: line number
// 5: column number
// 6: code frame, which includes code snippet indicators or terminal escape sequences for formatting.
var RE_METRO_ERROR_FORMAT = RegExp("^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)", "u");
// https://github.com/babel/babel/blob/33dbb85e9e9fe36915273080ecc42aee62ed0ade/packages/babel-code-frame/src/index.ts#L183-L184
var RE_BABEL_CODE_FRAME_MARKER_PATTERN = new RegExp([
    // Beginning of a line (per 'm' flag)
    '^',
    // Optional ANSI escapes for colors
    `(?:${ANSI_REGEX})*`,
    // Marker
    '>',
    // Optional ANSI escapes for colors
    `(?:${ANSI_REGEX})*`,
    // Left padding for line number
    ' +',
    // Line number
    '[0-9]+',
    // Gutter
    ' \\|'
].join(''), 'm');
function hasComponentStack(args) {
    for (var arg of args){
        if (typeof arg === 'string' && isComponentStack(arg)) {
            return true;
        }
    }
    return false;
}
var SUBSTITUTION = _UTFSequence.default.BOM + '%s';
function parseInterpolation(args) {
    var _categoryParts, _contentParts;
    var categoryParts = [];
    var contentParts = [];
    var substitutionOffsets = [];
    var remaining = _to_consumable_array._(args);
    if (typeof remaining[0] === 'string') {
        var formatString = String(remaining.shift());
        var formatStringParts = formatString.split('%s');
        var substitutionCount = formatStringParts.length - 1;
        var substitutions = remaining.splice(0, substitutionCount);
        var categoryString = '';
        var contentString = '';
        var substitutionIndex = 0;
        for (var formatStringPart of formatStringParts){
            categoryString += formatStringPart;
            contentString += formatStringPart;
            if (substitutionIndex < substitutionCount) {
                if (substitutionIndex < substitutions.length) {
                    // Don't stringify a string type.
                    // It adds quotation mark wrappers around the string,
                    // which causes the LogBox to look odd.
                    var substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : (0, _stringifySafe.default)(substitutions[substitutionIndex]);
                    substitutionOffsets.push({
                        length: substitution.length,
                        offset: contentString.length
                    });
                    categoryString += SUBSTITUTION;
                    contentString += substitution;
                } else {
                    substitutionOffsets.push({
                        length: 2,
                        offset: contentString.length
                    });
                    categoryString += '%s';
                    contentString += '%s';
                }
                substitutionIndex++;
            }
        }
        categoryParts.push(categoryString);
        contentParts.push(contentString);
    }
    var remainingArgs = remaining.map((arg)=>{
        // Don't stringify a string type.
        // It adds quotation mark wrappers around the string,
        // which causes the LogBox to look odd.
        return typeof arg === 'string' ? arg : (0, _stringifySafe.default)(arg);
    });
    (_categoryParts = categoryParts).push.apply(_categoryParts, _to_consumable_array._(remainingArgs));
    (_contentParts = contentParts).push.apply(_contentParts, _to_consumable_array._(remainingArgs));
    return {
        category: categoryParts.join(' '),
        message: {
            content: contentParts.join(' '),
            substitutions: substitutionOffsets
        }
    };
}
function isComponentStack(consoleArgument) {
    var isOldComponentStackFormat = RE_COMPONENT_STACK_LINE_OLD.test(consoleArgument);
    var isNewComponentStackFormat = RE_COMPONENT_STACK_LINE_NEW.test(consoleArgument);
    var isNewJSCComponentStackFormat = RE_COMPONENT_STACK_LINE_STACK_FRAME.test(consoleArgument);
    return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;
}
function parseComponentStack(message) {
    // In newer versions of React, the component stack is formatted as a call stack frame.
    // First try to parse the component stack as a call stack frame, and if that doesn't
    // work then we'll fallback to the old custom component stack format parsing.
    var stack = (0, _parseErrorStack.default)(message);
    if (stack && stack.length > 0) {
        return {
            type: 'stack',
            stack: stack.map((frame)=>({
                    content: frame.methodName,
                    collapse: frame.collapse || false,
                    fileName: frame.file == null ? 'unknown' : frame.file,
                    location: {
                        column: frame.column == null ? -1 : frame.column,
                        row: frame.lineNumber == null ? -1 : frame.lineNumber
                    }
                }))
        };
    }
    var legacyStack = message.split(RE_COMPONENT_STACK_LINE_GLOBAL).map((s)=>{
        if (!s) {
            return null;
        }
        var match = s.match(RE_COMPONENT_STACK_WITH_SOURCE);
        if (match) {
            var _match_slice = _sliced_to_array._(match.slice(1), 3), content = _match_slice[0], fileName = _match_slice[1], row = _match_slice[2];
            return {
                content,
                fileName,
                location: {
                    column: -1,
                    row: parseInt(row, 10)
                }
            };
        }
        // In some cases, the component stack doesn't have a source.
        var matchWithoutSource = s.match(RE_COMPONENT_STACK_NO_SOURCE);
        if (matchWithoutSource) {
            return {
                content: matchWithoutSource[1],
                fileName: '',
                location: null
            };
        }
        return null;
    }).filter(Boolean);
    return {
        type: 'legacy',
        stack: legacyStack
    };
}
function parseLogBoxException(error) {
    var message = error.originalMessage != null ? error.originalMessage : 'Unknown';
    var metroInternalError = message.match(RE_METRO_ERROR_FORMAT);
    if (metroInternalError) {
        var _metroInternalError_slice = _sliced_to_array._(metroInternalError.slice(1), 5), content = _metroInternalError_slice[0], fileName = _metroInternalError_slice[1], row = _metroInternalError_slice[2], column = _metroInternalError_slice[3], codeFrame = _metroInternalError_slice[4];
        return {
            level: 'fatal',
            type: 'Metro Error',
            stack: [],
            isComponentError: false,
            componentStackType: 'legacy',
            componentStack: [],
            codeFrame: {
                fileName,
                location: {
                    row: parseInt(row, 10),
                    column: parseInt(column, 10)
                },
                content: codeFrame
            },
            message: {
                content,
                substitutions: []
            },
            category: `${fileName}-${row}-${column}`,
            extraData: error.extraData
        };
    }
    var babelTransformError = message.match(RE_BABEL_TRANSFORM_ERROR_FORMAT);
    if (babelTransformError) {
        // Transform errors are thrown from inside the Babel transformer.
        var _babelTransformError_slice = _sliced_to_array._(babelTransformError.slice(1), 5), fileName1 = _babelTransformError_slice[0], content1 = _babelTransformError_slice[1], row1 = _babelTransformError_slice[2], column1 = _babelTransformError_slice[3], codeFrame1 = _babelTransformError_slice[4];
        return {
            level: 'syntax',
            stack: [],
            isComponentError: false,
            componentStackType: 'legacy',
            componentStack: [],
            codeFrame: {
                fileName: fileName1,
                location: {
                    row: parseInt(row1, 10),
                    column: parseInt(column1, 10)
                },
                content: codeFrame1
            },
            message: {
                content: content1,
                substitutions: []
            },
            category: `${fileName1}-${row1}-${column1}`,
            extraData: error.extraData
        };
    }
    // Perform a cheap match first before trying to parse the full message, which
    // can get expensive for arbitrary input.
    if (RE_BABEL_CODE_FRAME_MARKER_PATTERN.test(message)) {
        var babelCodeFrameError = message.match(RE_BABEL_CODE_FRAME_ERROR_FORMAT);
        if (babelCodeFrameError) {
            // Codeframe errors are thrown from any use of buildCodeFrameError.
            var _babelCodeFrameError_slice = _sliced_to_array._(babelCodeFrameError.slice(1), 3), fileName2 = _babelCodeFrameError_slice[0], content2 = _babelCodeFrameError_slice[1], codeFrame2 = _babelCodeFrameError_slice[2];
            return {
                level: 'syntax',
                stack: [],
                isComponentError: false,
                componentStackType: 'legacy',
                componentStack: [],
                codeFrame: {
                    fileName: fileName2,
                    location: null,
                    content: codeFrame2
                },
                message: {
                    content: content2,
                    substitutions: []
                },
                category: `${fileName2}-${1}-${1}`,
                extraData: error.extraData
            };
        }
    }
    if (message.match(RE_TRANSFORM_ERROR)) {
        return {
            level: 'syntax',
            stack: error.stack,
            isComponentError: error.isComponentError,
            componentStackType: 'legacy',
            componentStack: [],
            message: {
                content: message,
                substitutions: []
            },
            category: message,
            extraData: error.extraData
        };
    }
    var componentStack = error.componentStack;
    if (error.isFatal || error.isComponentError) {
        if (componentStack != null) {
            var _parseComponentStack = parseComponentStack(componentStack), type = _parseComponentStack.type, stack = _parseComponentStack.stack;
            return _object_spread._({
                level: 'fatal',
                stack: error.stack,
                isComponentError: error.isComponentError,
                componentStackType: type,
                componentStack: stack,
                extraData: error.extraData
            }, parseInterpolation([
                message
            ]));
        } else {
            return _object_spread._({
                level: 'fatal',
                stack: error.stack,
                isComponentError: error.isComponentError,
                componentStackType: 'legacy',
                componentStack: [],
                extraData: error.extraData
            }, parseInterpolation([
                message
            ]));
        }
    }
    if (componentStack != null) {
        // It is possible that console errors have a componentStack.
        var _parseComponentStack1 = parseComponentStack(componentStack), type1 = _parseComponentStack1.type, stack1 = _parseComponentStack1.stack;
        return _object_spread._({
            level: 'error',
            stack: error.stack,
            isComponentError: error.isComponentError,
            componentStackType: type1,
            componentStack: stack1,
            extraData: error.extraData
        }, parseInterpolation([
            message
        ]));
    }
    // Most `console.error` calls won't have a componentStack. We parse them like
    // regular logs which have the component stack buried in the message.
    return _object_spread._({
        level: 'error',
        stack: error.stack,
        isComponentError: error.isComponentError,
        extraData: error.extraData
    }, parseLogBoxLog([
        message
    ]));
}
function withoutANSIColorStyles(message) {
    if (typeof message !== 'string') {
        return message;
    }
    return message.replace(// eslint-disable-next-line no-control-regex
    /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
}
function parseLogBoxLog(args) {
    var message = withoutANSIColorStyles(args[0]);
    var argsWithoutComponentStack = [];
    var componentStack = [];
    var componentStackType = 'legacy';
    // Extract component stack from warnings like "Some warning%s".
    if (typeof message === 'string' && message.slice(-2) === '%s' && args.length > 0) {
        var lastArg = args[args.length - 1];
        if (typeof lastArg === 'string' && isComponentStack(lastArg)) {
            argsWithoutComponentStack = args.slice(0, -1);
            argsWithoutComponentStack[0] = message.slice(0, -2);
            var _parseComponentStack = parseComponentStack(lastArg), type = _parseComponentStack.type, stack = _parseComponentStack.stack;
            componentStack = stack;
            componentStackType = type;
        }
    }
    if (componentStack.length === 0 && argsWithoutComponentStack.length === 0) {
        // Try finding the component stack elsewhere.
        for (var arg of args){
            if (typeof arg === 'string' && isComponentStack(arg)) {
                // Strip out any messages before the component stack.
                var messageEndIndex = arg.search(RE_COMPONENT_STACK_LINE);
                if (messageEndIndex < 0) {
                    // Handle JSC component stacks.
                    messageEndIndex = arg.search(/\n/);
                }
                if (messageEndIndex > 0) {
                    argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));
                }
                var _parseComponentStack1 = parseComponentStack(arg), type1 = _parseComponentStack1.type, stack1 = _parseComponentStack1.stack;
                componentStack = stack1;
                componentStackType = type1;
            } else {
                argsWithoutComponentStack.push(arg);
            }
        }
    }
    return _object_spread_props._(_object_spread._({}, parseInterpolation(argsWithoutComponentStack)), {
        componentStack,
        componentStackType
    });
}


}),
"./node_modules/react-native/Libraries/LogBox/LogBox.js": 
/*!**************************************************************!*\
  !*** ./node_modules/react-native/Libraries/LogBox/LogBox.js ***!
  \**************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var _Platform = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../Utilities/Platform */ "./node_modules/react-native/Libraries/Utilities/Platform.android.js"));
var _RCTLog = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../Utilities/RCTLog */ "./node_modules/react-native/Libraries/Utilities/RCTLog.js"));
var _parseLogBoxLog = __webpack_require__(/*! ./Data/parseLogBoxLog */ "./node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js");
var LogBox;
/**
 * LogBox displays logs in the app.
 */ if (true) {
    var LogBoxData = __webpack_require__(/*! ./Data/LogBoxData */ "./node_modules/react-native/Libraries/LogBox/Data/LogBoxData.js");
    var _require = __webpack_require__(/*! ./Data/parseLogBoxLog */ "./node_modules/react-native/Libraries/LogBox/Data/parseLogBoxLog.js"), parseLogBoxLog = _require.parseLogBoxLog, parseInterpolation = _require.parseInterpolation;
    var originalConsoleError;
    var originalConsoleWarn;
    var consoleErrorImpl;
    var consoleWarnImpl;
    var isLogBoxInstalled = false;
    LogBox = {
        install () {
            if (isLogBoxInstalled) {
                return;
            }
            isLogBoxInstalled = true;
            if (__webpack_require__.g.RN$registerExceptionListener != null) {
                __webpack_require__.g.RN$registerExceptionListener((error)=>{
                    var _global_RN$isRuntimeReady, _global;
                    if (((_global_RN$isRuntimeReady = (_global = __webpack_require__.g).RN$isRuntimeReady) === null || _global_RN$isRuntimeReady === void 0 ? void 0 : _global_RN$isRuntimeReady.call(_global)) || !error.isFatal) {
                        error.preventDefault();
                        addException(error);
                    }
                });
            }
            // Trigger lazy initialization of module.
            __webpack_require__(/*! ../NativeModules/specs/NativeLogBox */ "./node_modules/react-native/Libraries/NativeModules/specs/NativeLogBox.js");
            // IMPORTANT: we only overwrite `console.error` and `console.warn` once.
            // When we uninstall we keep the same reference and only change its
            // internal implementation
            var isFirstInstall = originalConsoleError == null;
            if (isFirstInstall) {
                originalConsoleError = console.error.bind(console);
                originalConsoleWarn = console.warn.bind(console);
                // $FlowExpectedError[cannot-write]
                console.error = (...args)=>{
                    consoleErrorImpl.apply(void 0, _to_consumable_array._(args));
                };
                // $FlowExpectedError[cannot-write]
                console.warn = (...args)=>{
                    consoleWarnImpl.apply(void 0, _to_consumable_array._(args));
                };
            }
            consoleErrorImpl = registerError;
            consoleWarnImpl = registerWarning;
            if (_Platform.default.isTesting) {
                LogBoxData.setDisabled(true);
            }
            _RCTLog.default.setWarningHandler((...args)=>{
                registerWarning.apply(void 0, _to_consumable_array._(args));
            });
        },
        uninstall () {
            if (!isLogBoxInstalled) {
                return;
            }
            isLogBoxInstalled = false;
            // IMPORTANT: we don't re-assign to `console` in case the method has been
            // decorated again after installing LogBox. E.g.:
            // Before uninstalling: original > LogBox > OtherErrorHandler
            // After uninstalling:  original > LogBox (noop) > OtherErrorHandler
            consoleErrorImpl = originalConsoleError;
            consoleWarnImpl = originalConsoleWarn;
        },
        isInstalled () {
            return isLogBoxInstalled;
        },
        ignoreLogs (patterns) {
            LogBoxData.addIgnorePatterns(patterns);
        },
        ignoreAllLogs (value) {
            LogBoxData.setDisabled(value == null ? true : value);
        },
        clearAllLogs () {
            LogBoxData.clear();
        },
        addLog (log) {
            if (isLogBoxInstalled) {
                LogBoxData.addLog(log);
            }
        },
        addException
    };
    function addException(error) {
        if (isLogBoxInstalled) {
            LogBoxData.addException(error);
        }
    }
    var isRCTLogAdviceWarning = (...args)=>{
        // RCTLogAdvice is a native logging function designed to show users
        // a message in the console, but not show it to them in Logbox.
        return typeof args[0] === 'string' && args[0].startsWith('(ADVICE)');
    };
    var isWarningModuleWarning = (...args)=>{
        return typeof args[0] === 'string' && args[0].startsWith('Warning: ');
    };
    var registerWarning = (...args)=>{
        // Let warnings within LogBox itself fall through.
        if (LogBoxData.isLogBoxErrorMessage(String(args[0]))) {
            originalConsoleError.apply(void 0, _to_consumable_array._(args));
            return;
        } else {
            // Be sure to pass LogBox warnings through.
            originalConsoleWarn.apply(void 0, _to_consumable_array._(args));
        }
        try {
            if (!isRCTLogAdviceWarning.apply(void 0, _to_consumable_array._(args))) {
                var _parseLogBoxLog = parseLogBoxLog(args), category = _parseLogBoxLog.category, message = _parseLogBoxLog.message, componentStack = _parseLogBoxLog.componentStack, componentStackType = _parseLogBoxLog.componentStackType;
                if (!LogBoxData.isMessageIgnored(message.content)) {
                    LogBoxData.addLog({
                        level: 'warn',
                        category,
                        message,
                        componentStack,
                        componentStackType
                    });
                }
            }
        } catch (err) {
            LogBoxData.reportLogBoxError(err);
        }
    };
    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
   * LTI update could not be added via codemod */ var registerError = (...args)=>{
        // Let errors within LogBox itself fall through.
        if (LogBoxData.isLogBoxErrorMessage(args[0])) {
            originalConsoleError.apply(void 0, _to_consumable_array._(args));
            return;
        }
        try {
            if (!isWarningModuleWarning.apply(void 0, _to_consumable_array._(args)) && !(0, _parseLogBoxLog.hasComponentStack)(args)) {
                // Only show LogBox for the 'warning' module, or React errors with
                // component stacks, otherwise pass the error through.u
                //
                // By passing through, this will get picked up by the React console override,
                // potentially adding the component stack. React then passes it back to the
                // React Native ExceptionsManager, which reports it to LogBox as an error.
                //
                // Ideally, we refactor all RN error handling so that LogBox patching
                // errors is not necessary, and they are reported the same as a framework.
                // The blocker to this is that the ExceptionManager console.error override
                // strigifys all of the args before passing it through to LogBox, which
                // would lose all of the interpolation information.
                //
                // The 'warning' module needs to be handled here because React internally calls
                // `console.error('Warning: ')` with the component stack already included.
                originalConsoleError.apply(void 0, _to_consumable_array._(args));
                return;
            }
            var format = args[0].replace('Warning: ', '');
            var filterResult = LogBoxData.checkWarningFilter(format);
            var level = 'error';
            if (filterResult.monitorEvent !== 'warning_unhandled') {
                if (filterResult.suppressCompletely) {
                    return;
                }
                if (filterResult.suppressDialog_LEGACY === true) {
                    level = 'warn';
                } else if (filterResult.forceDialogImmediately === true) {
                    level = 'fatal'; // Do not downgrade. These are real bugs with same severity as throws.
                }
            }
            // Unfortunately, we need to add the Warning: prefix back for downstream dependencies.
            // Downstream, we check for this prefix to know that LogBox already handled it, so
            // it doesn't get reported back to LogBox. It's an absolute mess.
            args[0] = `Warning: ${filterResult.finalFormat}`;
            var _parseLogBoxLog1 = parseLogBoxLog(args), category = _parseLogBoxLog1.category, message = _parseLogBoxLog1.message, componentStack = _parseLogBoxLog1.componentStack, componentStackType = _parseLogBoxLog1.componentStackType;
            // Interpolate the message so they are formatted for adb and other CLIs.
            // This is different than the message.content above because it includes component stacks.
            var interpolated = parseInterpolation(args);
            originalConsoleError(interpolated.message.content);
            if (!LogBoxData.isMessageIgnored(message.content)) {
                LogBoxData.addLog({
                    level,
                    category,
                    message,
                    componentStack,
                    componentStackType
                });
            }
        } catch (err) {
            LogBoxData.reportLogBoxError(err);
        }
    };
} else {}
var _default = LogBox;


}),
"./node_modules/react-native/Libraries/Network/fetch.js": 
/*!**************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Network/fetch.js ***!
  \**************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ /* globals Headers, Request, Response */ 
// side-effectful require() to put fetch,
// Headers, Request, Response in global scope
__webpack_require__(/*! whatwg-fetch */ "./node_modules/whatwg-fetch/dist/fetch.umd.js");
module.exports = {
    fetch,
    Headers,
    Request,
    Response
};


}),
"./node_modules/react-native/Libraries/ReactNative/RendererImplementation.js": 
/*!***********************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/ReactNative/RendererImplementation.js ***!
  \***********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get dispatchCommand () {
        return dispatchCommand;
    },
    get findHostInstance_DEPRECATED () {
        return findHostInstance_DEPRECATED;
    },
    get findNodeHandle () {
        return findNodeHandle;
    },
    get getNodeFromInternalInstanceHandle () {
        return getNodeFromInternalInstanceHandle;
    },
    get getPublicInstanceFromInternalInstanceHandle () {
        return getPublicInstanceFromInternalInstanceHandle;
    },
    get isChildPublicInstance () {
        return isChildPublicInstance;
    },
    get isProfilingRenderer () {
        return isProfilingRenderer;
    },
    get renderElement () {
        return renderElement;
    },
    get sendAccessibilityEvent () {
        return sendAccessibilityEvent;
    },
    get unmountComponentAtNodeAndRemoveContainer () {
        return unmountComponentAtNodeAndRemoveContainer;
    },
    get unstable_batchedUpdates () {
        return unstable_batchedUpdates;
    }
});
var _ErrorHandlers = __webpack_require__(/*! ../../src/private/renderer/errorhandling/ErrorHandlers */ "./node_modules/react-native/src/private/renderer/errorhandling/ErrorHandlers.js");
function renderElement(ref) {
    var element = ref.element, rootTag = ref.rootTag, useFabric = ref.useFabric, useConcurrentRoot = ref.useConcurrentRoot;
    if (useFabric) {
        (__webpack_require__(/*! ../Renderer/shims/ReactFabric */ "./node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js")/* ["default"].render */["default"].render)(element, rootTag, null, useConcurrentRoot, {
            onCaughtError: _ErrorHandlers.onCaughtError,
            onUncaughtError: _ErrorHandlers.onUncaughtError,
            onRecoverableError: _ErrorHandlers.onRecoverableError
        });
    } else {
        (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].render */["default"].render)(element, rootTag, undefined, {
            onCaughtError: _ErrorHandlers.onCaughtError,
            onUncaughtError: _ErrorHandlers.onUncaughtError,
            onRecoverableError: _ErrorHandlers.onRecoverableError
        });
    }
}
function findHostInstance_DEPRECATED(componentOrHandle) {
    return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].findHostInstance_DEPRECATED */["default"].findHostInstance_DEPRECATED)(componentOrHandle);
}
function findNodeHandle(componentOrHandle) {
    return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].findNodeHandle */["default"].findNodeHandle)(componentOrHandle);
}
function dispatchCommand(handle, command, args) {
    if (__webpack_require__.g.RN$Bridgeless === true) {
        // Note: this function has the same implementation in the legacy and new renderer.
        // However, evaluating the old renderer comes with some side effects.
        return (__webpack_require__(/*! ../Renderer/shims/ReactFabric */ "./node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js")/* ["default"].dispatchCommand */["default"].dispatchCommand)(handle, command, args);
    } else {
        return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].dispatchCommand */["default"].dispatchCommand)(handle, command, args);
    }
}
function sendAccessibilityEvent(handle, eventType) {
    return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].sendAccessibilityEvent */["default"].sendAccessibilityEvent)(handle, eventType);
}
function unmountComponentAtNodeAndRemoveContainer(rootTag) {
    // $FlowExpectedError[incompatible-type] rootTag is an opaque type so we can't really cast it as is.
    var rootTagAsNumber = rootTag;
    (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].unmountComponentAtNodeAndRemoveContainer */["default"].unmountComponentAtNodeAndRemoveContainer)(rootTagAsNumber);
}
function unstable_batchedUpdates(fn, bookkeeping) {
    // This doesn't actually do anything when batching updates for a Fabric root.
    return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].unstable_batchedUpdates */["default"].unstable_batchedUpdates)(fn, bookkeeping);
}
function isProfilingRenderer() {
    return Boolean(true);
}
function isChildPublicInstance(parentInstance, childInstance) {
    return (__webpack_require__(/*! ../Renderer/shims/ReactNative */ "./node_modules/react-native/Libraries/Renderer/shims/ReactNative.js")/* ["default"].isChildPublicInstance */["default"].isChildPublicInstance)(parentInstance, childInstance);
}
function getNodeFromInternalInstanceHandle(internalInstanceHandle) {
    // This is only available in Fabric
    return (__webpack_require__(/*! ../Renderer/shims/ReactFabric */ "./node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js")/* ["default"].getNodeFromInternalInstanceHandle */["default"].getNodeFromInternalInstanceHandle)(internalInstanceHandle);
}
function getPublicInstanceFromInternalInstanceHandle(internalInstanceHandle) /*PublicInstance | PublicTextInstance | null*/ {
    // This is only available in Fabric
    return (__webpack_require__(/*! ../Renderer/shims/ReactFabric */ "./node_modules/react-native/Libraries/Renderer/shims/ReactFabric.js")/* ["default"].getPublicInstanceFromInternalInstanceHandle */["default"].getPublicInstanceFromInternalInstanceHandle)(internalInstanceHandle);
}


}),
"./node_modules/react-native/Libraries/ReactNative/RendererProxy.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/ReactNative/RendererProxy.js ***!
  \**************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ /**
 * This module exists to allow apps to select their renderer implementation
 * (e.g.: Fabric-only, Paper-only) without having to pull all the renderer
 * implementations into their app bundle, which affects app size.
 *
 * By default, the setup will be:
 *   -> RendererProxy
 *     -> RendererImplementation (which uses Fabric or Paper depending on a flag at runtime)
 *
 * But this will allow a setup like this without duplicating logic:
 *   -> RendererProxy (fork)
 *     -> RendererImplementation (which uses Fabric or Paper depending on a flag at runtime)
 *     or -> OtherImplementation (which uses Fabric only)
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _export_star = __webpack_require__(/*! @swc/helpers/_/_export_star */ "./node_modules/@swc/helpers/cjs/_export_star.cjs");
_export_star._(__webpack_require__(/*! ./RendererImplementation */ "./node_modules/react-native/Libraries/ReactNative/RendererImplementation.js"), exports);


}),
"./node_modules/react-native/Libraries/UTFSequence.js": 
/*!************************************************************!*\
  !*** ./node_modules/react-native/Libraries/UTFSequence.js ***!
  \************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var deepFreezeAndThrowOnMutationInDev = __webpack_require__(/*! ./Utilities/deepFreezeAndThrowOnMutationInDev */ "./node_modules/react-native/Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js");
/**
 * A collection of Unicode sequences for various characters and emoji.
 *
 *  - More explicit than using the sequences directly in code.
 *  - Source code should be limited to ASCII.
 *  - Less chance of typos.
 */ var UTFSequence = deepFreezeAndThrowOnMutationInDev({
    BOM: '\ufeff',
    BULLET: '\u2022',
    BULLET_SP: '\u00A0\u2022\u00A0',
    MIDDOT: '\u00B7',
    MIDDOT_SP: '\u00A0\u00B7\u00A0',
    MIDDOT_KATAKANA: '\u30FB',
    MDASH: '\u2014',
    MDASH_SP: '\u00A0\u2014\u00A0',
    NDASH: '\u2013',
    NDASH_SP: '\u00A0\u2013\u00A0',
    NEWLINE: '\u000A',
    NBSP: '\u00A0',
    PIZZA: '\uD83C\uDF55',
    TRIANGLE_LEFT: '\u25c0',
    TRIANGLE_RIGHT: '\u25b6'
});
var _default = UTFSequence;


}),
"./node_modules/react-native/Libraries/Utilities/RCTLog.js": 
/*!*****************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Utilities/RCTLog.js ***!
  \*****************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var invariant = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
var levelsMap = {
    log: 'log',
    info: 'info',
    warn: 'warn',
    error: 'error',
    fatal: 'error'
};
var warningHandler = null;
var RCTLog = {
    // level one of log, info, warn, error, mustfix
    logIfNoNativeHook (level, ...args) {
        // We already printed in the native console, so only log here if using a js debugger
        if (typeof __webpack_require__.g.nativeLoggingHook === 'undefined') {
            var _RCTLog;
            (_RCTLog = RCTLog).logToConsole.apply(_RCTLog, [
                level
            ].concat(_to_consumable_array._(args)));
        } else {
            // Report native warnings to LogBox
            if (warningHandler && level === 'warn') {
                warningHandler.apply(void 0, _to_consumable_array._(args));
            }
        }
    },
    // Log to console regardless of nativeLoggingHook
    logToConsole (level, ...args) {
        var _console;
        // $FlowFixMe[invalid-computed-prop]
        var logFn = levelsMap[level];
        invariant(logFn, 'Level "' + level + '" not one of ' + Object.keys(levelsMap).toString());
        (_console = console)[logFn].apply(_console, _to_consumable_array._(args));
    },
    setWarningHandler (handler) {
        warningHandler = handler;
    }
};
module.exports = RCTLog;


}),
"./node_modules/react-native/src/private/debugging/FuseboxSessionObserver.js": 
/*!***********************************************************************************!*\
  !*** ./node_modules/react-native/src/private/debugging/FuseboxSessionObserver.js ***!
  \***********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 * @oncall react_native
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _class_private_field_loose_base = __webpack_require__(/*! @swc/helpers/_/_class_private_field_loose_base */ "./node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs");
var _class_private_field_loose_key = __webpack_require__(/*! @swc/helpers/_/_class_private_field_loose_key */ "./node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _hasNativeSupport = /*#__PURE__*/ _class_private_field_loose_key._("_hasNativeSupport");
var FuseboxSessionObserver = /*#__PURE__*/ function() {
    "use strict";
    function FuseboxSessionObserver() {
        _class_call_check._(this, FuseboxSessionObserver);
        Object.defineProperty(this, _hasNativeSupport, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base._(this, _hasNativeSupport)[_hasNativeSupport] = __webpack_require__.g.hasOwnProperty('__DEBUGGER_SESSION_OBSERVER__');
    }
    _create_class._(FuseboxSessionObserver, [
        {
            key: "hasActiveSession",
            value: function hasActiveSession() {
                if (!_class_private_field_loose_base._(this, _hasNativeSupport)[_hasNativeSupport]) {
                    return false;
                }
                return __webpack_require__.g.__DEBUGGER_SESSION_OBSERVER__.hasActiveSession;
            }
        },
        {
            key: "subscribe",
            value: function subscribe(callback) {
                if (!_class_private_field_loose_base._(this, _hasNativeSupport)[_hasNativeSupport]) {
                    return ()=>{};
                }
                __webpack_require__.g.__DEBUGGER_SESSION_OBSERVER__.subscribers.add(callback);
                return ()=>{
                    __webpack_require__.g.__DEBUGGER_SESSION_OBSERVER__.subscribers.delete(callback);
                };
            }
        }
    ]);
    return FuseboxSessionObserver;
}();
var observerInstance = new FuseboxSessionObserver();
var _default = observerInstance;


}),
"./node_modules/react-native/src/private/renderer/errorhandling/ErrorHandlers.js": 
/*!***************************************************************************************!*\
  !*** ./node_modules/react-native/src/private/renderer/errorhandling/ErrorHandlers.js ***!
  \***************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get onCaughtError () {
        return onCaughtError;
    },
    get onRecoverableError () {
        return onRecoverableError;
    },
    get onUncaughtError () {
        return onUncaughtError;
    }
});
var _ExceptionsManager = __webpack_require__(/*! ../../../../Libraries/Core/ExceptionsManager */ "./node_modules/react-native/Libraries/Core/ExceptionsManager.js");
function getExtendedError(errorValue, errorInfo) {
    var error;
    // Typically, `errorValue` should be an error. However, other values such as
    // strings (or even null) are sometimes thrown.
    if (errorValue instanceof Error) {
        /* $FlowFixMe[class-object-subtyping] added when improving typing for
     * this parameters */ // $FlowFixMe[incompatible-cast]
        error = errorValue;
    } else if (typeof errorValue === 'string') {
        /* $FlowFixMe[class-object-subtyping] added when improving typing for
     * this parameters */ // $FlowFixMe[incompatible-cast]
        error = new _ExceptionsManager.SyntheticError(errorValue);
    } else {
        /* $FlowFixMe[class-object-subtyping] added when improving typing for
     * this parameters */ // $FlowFixMe[incompatible-cast]
        error = new _ExceptionsManager.SyntheticError('Unspecified error');
    }
    try {
        // $FlowFixMe[incompatible-use] this is in try/catch.
        error.componentStack = errorInfo.componentStack;
        error.isComponentError = true;
    } catch  {
    // Ignored.
    }
    return error;
}
function onUncaughtError(errorValue, errorInfo) {
    var error = getExtendedError(errorValue, errorInfo);
    // Uncaught errors are fatal.
    (0, _ExceptionsManager.handleException)(error, true);
}
function onCaughtError(errorValue, errorInfo) {
    var error = getExtendedError(errorValue, errorInfo);
    // Caught errors are not fatal.
    (0, _ExceptionsManager.handleException)(error, false);
}
function onRecoverableError(errorValue, errorInfo) {
    var error = getExtendedError(errorValue, errorInfo);
    // Recoverable errors should only be warnings.
    // This will make it a soft error in LogBox.
    // TODO: improve the logging for recoverable errors in prod.
    console.warn(error);
}


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native_Libraries_ReactNative_RendererProxy_js.chunk.bundle.map?platform=android