(self["webpackChunksataccommodation"] = self["webpackChunksataccommodation"] || []).push([["vendors-node_modules_react-native_Libraries_Components_View_ReactNativeStyleAttributes_js"], {
"./node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js": 
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Components/View/ReactNativeStyleAttributes.js ***!
  \*******************************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format strict-local
 *       strict-local
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _processAspectRatio = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processAspectRatio */ "./node_modules/react-native/Libraries/StyleSheet/processAspectRatio.js"));
var _processBackgroundImage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processBackgroundImage */ "./node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js"));
var _processBoxShadow = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processBoxShadow */ "./node_modules/react-native/Libraries/StyleSheet/processBoxShadow.js"));
var _processColor = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processColor */ "./node_modules/react-native/Libraries/StyleSheet/processColor.js"));
var _processFilter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processFilter */ "./node_modules/react-native/Libraries/StyleSheet/processFilter.js"));
var _processFontVariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processFontVariant */ "./node_modules/react-native/Libraries/StyleSheet/processFontVariant.js"));
var _processTransform = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processTransform */ "./node_modules/react-native/Libraries/StyleSheet/processTransform.js"));
var _processTransformOrigin = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../StyleSheet/processTransformOrigin */ "./node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js"));
var _sizesDiffer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../Utilities/differ/sizesDiffer */ "./node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js"));
var colorAttributes = {
    process: _processColor.default
};
var ReactNativeStyleAttributes = {
    /**
   * Layout
   */ alignContent: true,
    alignItems: true,
    alignSelf: true,
    aspectRatio: {
        process: _processAspectRatio.default
    },
    borderBottomWidth: true,
    borderEndWidth: true,
    borderLeftWidth: true,
    borderRightWidth: true,
    borderStartWidth: true,
    borderTopWidth: true,
    boxSizing: true,
    columnGap: true,
    borderWidth: true,
    bottom: true,
    direction: true,
    display: true,
    end: true,
    flex: true,
    flexBasis: true,
    flexDirection: true,
    flexGrow: true,
    flexShrink: true,
    flexWrap: true,
    gap: true,
    height: true,
    inset: true,
    insetBlock: true,
    insetBlockEnd: true,
    insetBlockStart: true,
    insetInline: true,
    insetInlineEnd: true,
    insetInlineStart: true,
    justifyContent: true,
    left: true,
    margin: true,
    marginBlock: true,
    marginBlockEnd: true,
    marginBlockStart: true,
    marginBottom: true,
    marginEnd: true,
    marginHorizontal: true,
    marginInline: true,
    marginInlineEnd: true,
    marginInlineStart: true,
    marginLeft: true,
    marginRight: true,
    marginStart: true,
    marginTop: true,
    marginVertical: true,
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true,
    overflow: true,
    padding: true,
    paddingBlock: true,
    paddingBlockEnd: true,
    paddingBlockStart: true,
    paddingBottom: true,
    paddingEnd: true,
    paddingHorizontal: true,
    paddingInline: true,
    paddingInlineEnd: true,
    paddingInlineStart: true,
    paddingLeft: true,
    paddingRight: true,
    paddingStart: true,
    paddingTop: true,
    paddingVertical: true,
    position: true,
    right: true,
    rowGap: true,
    start: true,
    top: true,
    width: true,
    zIndex: true,
    /**
   * Shadow
   */ elevation: true,
    shadowColor: colorAttributes,
    shadowOffset: {
        diff: _sizesDiffer.default
    },
    shadowOpacity: true,
    shadowRadius: true,
    /**
   * Transform
   */ transform: {
        process: _processTransform.default
    },
    transformOrigin: {
        process: _processTransformOrigin.default
    },
    /**
   * Filter
   */ filter: {
        process: _processFilter.default
    },
    /**
   * MixBlendMode
   */ mixBlendMode: true,
    /**
   * Isolation
   */ isolation: true,
    /*
   * BoxShadow
   */ boxShadow: {
        process: _processBoxShadow.default
    },
    /**
   * Linear Gradient
   */ experimental_backgroundImage: {
        process: _processBackgroundImage.default
    },
    /**
   * View
   */ backfaceVisibility: true,
    backgroundColor: colorAttributes,
    borderBlockColor: colorAttributes,
    borderBlockEndColor: colorAttributes,
    borderBlockStartColor: colorAttributes,
    borderBottomColor: colorAttributes,
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderColor: colorAttributes,
    borderCurve: true,
    borderEndColor: colorAttributes,
    borderEndEndRadius: true,
    borderEndStartRadius: true,
    borderLeftColor: colorAttributes,
    borderRadius: true,
    borderRightColor: colorAttributes,
    borderStartColor: colorAttributes,
    borderStartEndRadius: true,
    borderStartStartRadius: true,
    borderStyle: true,
    borderTopColor: colorAttributes,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    cursor: true,
    opacity: true,
    outlineColor: colorAttributes,
    outlineOffset: true,
    outlineStyle: true,
    outlineWidth: true,
    pointerEvents: true,
    /**
   * Text
   */ color: colorAttributes,
    fontFamily: true,
    fontSize: true,
    fontStyle: true,
    fontVariant: {
        process: _processFontVariant.default
    },
    fontWeight: true,
    includeFontPadding: true,
    letterSpacing: true,
    lineHeight: true,
    textAlign: true,
    textAlignVertical: true,
    textDecorationColor: colorAttributes,
    textDecorationLine: true,
    textDecorationStyle: true,
    textShadowColor: colorAttributes,
    textShadowOffset: true,
    textShadowRadius: true,
    textTransform: true,
    userSelect: true,
    verticalAlign: true,
    writingDirection: true,
    /**
   * Image
   */ overlayColor: colorAttributes,
    resizeMode: true,
    tintColor: colorAttributes,
    objectFit: true
};
module.exports = ReactNativeStyleAttributes;


}),
"./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.android.js": 
/*!*******************************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.android.js ***!
  \*******************************************************************************************/
(function (__unused_webpack_module, exports) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ /** The actual type of the opaque NativeColorValue on Android platform */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get PlatformColor () {
        return PlatformColor;
    },
    get normalizeColorObject () {
        return normalizeColorObject;
    },
    get processColorObject () {
        return processColorObject;
    }
});
var PlatformColor = (...names)=>{
    /* $FlowExpectedError[incompatible-return]
   * LocalNativeColorValue is the actual type of the opaque NativeColorValue on Android platform */ return {
        resource_paths: names
    };
};
var normalizeColorObject = (color)=>{
    /* $FlowExpectedError[incompatible-cast]
   * LocalNativeColorValue is the actual type of the opaque NativeColorValue on Android platform */ if ('resource_paths' in color) {
        return color;
    }
    return null;
};
var processColorObject = (color)=>{
    return color;
};


}),
"./node_modules/react-native/Libraries/StyleSheet/normalizeColor.js": 
/*!**************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/normalizeColor.js ***!
  \**************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ /* eslint no-bitwise: 0 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _normalizecolors = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! @react-native/normalize-colors */ "webpack/sharing/consume/default/@react-native/normalize-colors/@react-native/normalize-colors"));
function normalizeColor(color) {
    if (typeof color === 'object' && color != null) {
        var normalizeColorObject = (__webpack_require__(/*! ./PlatformColorValueTypes */ "./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.android.js")/* .normalizeColorObject */.normalizeColorObject);
        var normalizedColor = normalizeColorObject(color);
        if (normalizedColor != null) {
            return normalizedColor;
        }
    }
    if (typeof color === 'string' || typeof color === 'number') {
        return (0, _normalizecolors.default)(color);
    }
}
module.exports = normalizeColor;


}),
"./node_modules/react-native/Libraries/StyleSheet/processAspectRatio.js": 
/*!******************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processAspectRatio.js ***!
  \******************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ 
var invariant = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
function processAspectRatio(aspectRatio) {
    if (typeof aspectRatio === 'number') {
        return aspectRatio;
    }
    if (typeof aspectRatio !== 'string') {
        if (true) {
            invariant(!aspectRatio, 'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s', aspectRatio);
        }
        return;
    }
    var matches = aspectRatio.split('/').map((s)=>s.trim());
    if (matches.includes('auto')) {
        if (true) {
            invariant(matches.length, 'aspectRatio does not support `auto <ratio>`. You passed: %s', aspectRatio);
        }
        return;
    }
    var hasNonNumericValues = matches.some((n)=>Number.isNaN(Number(n)));
    if (true) {
        invariant(!hasNonNumericValues && (matches.length === 1 || matches.length === 2), 'aspectRatio must either be a number, a ratio string or `auto`. You passed: %s', aspectRatio);
    }
    if (hasNonNumericValues) {
        return;
    }
    if (matches.length === 2) {
        return Number(matches[0]) / Number(matches[1]);
    }
    return Number(matches[0]);
}
module.exports = processAspectRatio;


}),
"./node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js": 
/*!**********************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js ***!
  \**********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return processBackgroundImage;
    }
}));
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var processColor = (__webpack_require__(/*! ./processColor */ "./node_modules/react-native/Libraries/StyleSheet/processColor.js")/* ["default"] */["default"]);
var DIRECTION_KEYWORD_REGEX = /^to\s+(?:top|bottom|left|right)(?:\s+(?:top|bottom|left|right))?/i;
var ANGLE_UNIT_REGEX = /^([+-]?\d*\.?\d+)(deg|grad|rad|turn)$/i;
var DEFAULT_DIRECTION = {
    type: 'angle',
    value: 180
};
function processBackgroundImage(backgroundImage) {
    var result = [];
    if (backgroundImage == null) {
        return result;
    }
    if (typeof backgroundImage === 'string') {
        result = parseCSSLinearGradient(backgroundImage.replace(/\n/g, ' '));
    } else if (Array.isArray(backgroundImage)) {
        for (var bgImage of backgroundImage){
            var processedColorStops = [];
            for(var index = 0; index < bgImage.colorStops.length; index++){
                var colorStop = bgImage.colorStops[index];
                var processedColor = processColor(colorStop.color);
                if (processedColor == null) {
                    // If a color is invalid, return an empty array and do not apply gradient. Same as web.
                    return [];
                }
                if (colorStop.positions != null && colorStop.positions.length > 0) {
                    for (var position of colorStop.positions){
                        if (position.endsWith('%')) {
                            processedColorStops.push({
                                color: processedColor,
                                position: parseFloat(position) / 100
                            });
                        } else {
                            // If a position is invalid, return an empty array and do not apply gradient. Same as web.
                            return [];
                        }
                    }
                } else {
                    processedColorStops.push({
                        color: processedColor,
                        position: null
                    });
                }
            }
            var direction = DEFAULT_DIRECTION;
            var bgDirection = bgImage.direction != null ? bgImage.direction.toLowerCase() : null;
            if (bgDirection != null) {
                if (ANGLE_UNIT_REGEX.test(bgDirection)) {
                    var parsedAngle = getAngleInDegrees(bgDirection);
                    if (parsedAngle != null) {
                        direction = {
                            type: 'angle',
                            value: parsedAngle
                        };
                    } else {
                        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.
                        return [];
                    }
                } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {
                    var parsedDirection = getDirectionForKeyword(bgDirection);
                    if (parsedDirection != null) {
                        direction = parsedDirection;
                    } else {
                        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.
                        return [];
                    }
                } else {
                    // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.
                    return [];
                }
            }
            var fixedColorStops = getFixedColorStops(processedColorStops);
            result = result.concat({
                type: 'linearGradient',
                direction,
                colorStops: fixedColorStops
            });
        }
    }
    return result;
}
function parseCSSLinearGradient(cssString) {
    var gradients = [];
    var match;
    // matches one or more linear-gradient functions in CSS
    var linearGradientRegex = /linear-gradient\s*\(((?:\([^)]*\)|[^())])*)\)/gi;
    while(match = linearGradientRegex.exec(cssString)){
        var gradientContent = match[1];
        var parts = gradientContent.split(',');
        var direction = DEFAULT_DIRECTION;
        var trimmedDirection = parts[0].trim().toLowerCase();
        // matches individual color stops in a gradient function
        // supports various color formats: named colors, hex colors, rgb(a), and hsl(a)
        // e.g. "red 20%", "blue 50%", "rgba(0, 0, 0, 0.5) 30% 50%"
        // TODO: does not support color hint syntax yet. It is WIP.
        var colorStopRegex = /\s*((?:(?:rgba?|hsla?)\s*\([^)]+\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\s+(-?[0-9.]+%?)(?:\s+(-?[0-9.]+%?))?)?\s*/gi;
        if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {
            var parsedAngle = getAngleInDegrees(trimmedDirection);
            if (parsedAngle != null) {
                direction = {
                    type: 'angle',
                    value: parsedAngle
                };
                parts.shift();
            } else {
                // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.
                return [];
            }
        } else if (DIRECTION_KEYWORD_REGEX.test(trimmedDirection)) {
            var parsedDirection = getDirectionForKeyword(trimmedDirection);
            if (parsedDirection != null) {
                direction = parsedDirection;
                parts.shift();
            } else {
                // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.
                return [];
            }
        } else if (!colorStopRegex.test(trimmedDirection)) {
            // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.
            return [];
        }
        colorStopRegex.lastIndex = 0;
        var colorStops = [];
        var fullColorStopsStr = parts.join(',');
        var colorStopMatch = void 0;
        while(colorStopMatch = colorStopRegex.exec(fullColorStopsStr)){
            var _colorStopMatch = _sliced_to_array._(colorStopMatch, 4), color = _colorStopMatch[1], position1 = _colorStopMatch[2], position2 = _colorStopMatch[3];
            var processedColor = processColor(color.trim().toLowerCase());
            if (processedColor == null) {
                // If a color is invalid, return an empty array and do not apply any gradient. Same as web.
                return [];
            }
            if (typeof position1 !== 'undefined') {
                if (position1.endsWith('%')) {
                    colorStops.push({
                        color: processedColor,
                        position: parseFloat(position1) / 100
                    });
                } else {
                    // If a position is invalid, return an empty array and do not apply any gradient. Same as web.
                    return [];
                }
            } else {
                colorStops.push({
                    color: processedColor,
                    position: null
                });
            }
            if (typeof position2 !== 'undefined') {
                if (position2.endsWith('%')) {
                    colorStops.push({
                        color: processedColor,
                        position: parseFloat(position2) / 100
                    });
                } else {
                    // If a position is invalid, return an empty array and do not apply any gradient. Same as web.
                    return [];
                }
            }
        }
        var fixedColorStops = getFixedColorStops(colorStops);
        gradients.push({
            type: 'linearGradient',
            direction,
            colorStops: fixedColorStops
        });
    }
    return gradients;
}
function getDirectionForKeyword(direction) {
    if (direction == null) {
        return null;
    }
    // Remove extra whitespace
    var normalized = direction.replace(/\s+/g, ' ').toLowerCase();
    switch(normalized){
        case 'to top':
            return {
                type: 'angle',
                value: 0
            };
        case 'to right':
            return {
                type: 'angle',
                value: 90
            };
        case 'to bottom':
            return {
                type: 'angle',
                value: 180
            };
        case 'to left':
            return {
                type: 'angle',
                value: 270
            };
        case 'to top right':
        case 'to right top':
            return {
                type: 'keyword',
                value: 'to top right'
            };
        case 'to bottom right':
        case 'to right bottom':
            return {
                type: 'keyword',
                value: 'to bottom right'
            };
        case 'to top left':
        case 'to left top':
            return {
                type: 'keyword',
                value: 'to top left'
            };
        case 'to bottom left':
        case 'to left bottom':
            return {
                type: 'keyword',
                value: 'to bottom left'
            };
        default:
            return null;
    }
}
function getAngleInDegrees(angle) {
    if (angle == null) {
        return null;
    }
    var match = angle.match(ANGLE_UNIT_REGEX);
    if (!match) {
        return null;
    }
    var _match = _sliced_to_array._(match, 3), value = _match[1], unit = _match[2];
    var numericValue = parseFloat(value);
    switch(unit){
        case 'deg':
            return numericValue;
        case 'grad':
            return numericValue * 0.9; // 1 grad = 0.9 degrees
        case 'rad':
            return numericValue * 180 / Math.PI;
        case 'turn':
            return numericValue * 360; // 1 turn = 360 degrees
        default:
            return null;
    }
}
// https://drafts.csswg.org/css-images-4/#color-stop-fixup
function getFixedColorStops(colorStops) {
    var fixedColorStops = [];
    var hasNullPositions = false;
    var maxPositionSoFar = colorStops[0].position ?? 0;
    for(var i = 0; i < colorStops.length; i++){
        var colorStop = colorStops[i];
        var newPosition = colorStop.position;
        if (newPosition === null) {
            // Step 1:
            // If the first color stop does not have a position,
            // set its position to 0%. If the last color stop does not have a position,
            // set its position to 100%.
            if (i === 0) {
                newPosition = 0;
            } else if (i === colorStops.length - 1) {
                newPosition = 1;
            }
        }
        // Step 2:
        // If a color stop or transition hint has a position
        // that is less than the specified position of any color stop or transition hint
        // before it in the list, set its position to be equal to the
        // largest specified position of any color stop or transition hint before it.
        if (newPosition !== null) {
            newPosition = Math.max(newPosition, maxPositionSoFar);
            fixedColorStops[i] = {
                color: colorStop.color,
                position: newPosition
            };
            maxPositionSoFar = newPosition;
        } else {
            hasNullPositions = true;
        }
    }
    // Step 3:
    // If any color stop still does not have a position,
    // then, for each run of adjacent color stops without positions,
    // set their positions so that they are evenly spaced between the preceding and
    // following color stops with positions.
    if (hasNullPositions) {
        var lastDefinedIndex = 0;
        for(var i1 = 1; i1 < fixedColorStops.length; i1++){
            if (fixedColorStops[i1] !== undefined) {
                var unpositionedStops = i1 - lastDefinedIndex - 1;
                if (unpositionedStops > 0) {
                    var startPosition = fixedColorStops[lastDefinedIndex].position;
                    var endPosition = fixedColorStops[i1].position;
                    var increment = (endPosition - startPosition) / (unpositionedStops + 1);
                    for(var j = 1; j <= unpositionedStops; j++){
                        fixedColorStops[lastDefinedIndex + j] = {
                            color: colorStops[lastDefinedIndex + j].color,
                            position: startPosition + increment * j
                        };
                    }
                }
                lastDefinedIndex = i1;
            }
        }
    }
    return fixedColorStops;
}


}),
"./node_modules/react-native/Libraries/StyleSheet/processBoxShadow.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processBoxShadow.js ***!
  \****************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 * @oncall react-native
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return processBoxShadow;
    }
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _processColor = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./processColor */ "./node_modules/react-native/Libraries/StyleSheet/processColor.js"));
function processBoxShadow(rawBoxShadows) {
    var result = [];
    if (rawBoxShadows == null) {
        return result;
    }
    var boxShadowList = typeof rawBoxShadows === 'string' ? parseBoxShadowString(rawBoxShadows.replace(/\n/g, ' ')) : rawBoxShadows;
    for (var rawBoxShadow of boxShadowList){
        var parsedBoxShadow = {
            offsetX: 0,
            offsetY: 0
        };
        var value = void 0;
        for(var arg in rawBoxShadow){
            switch(arg){
                case 'offsetX':
                    value = typeof rawBoxShadow.offsetX === 'string' ? parseLength(rawBoxShadow.offsetX) : rawBoxShadow.offsetX;
                    if (value == null) {
                        return [];
                    }
                    parsedBoxShadow.offsetX = value;
                    break;
                case 'offsetY':
                    value = typeof rawBoxShadow.offsetY === 'string' ? parseLength(rawBoxShadow.offsetY) : rawBoxShadow.offsetY;
                    if (value == null) {
                        return [];
                    }
                    parsedBoxShadow.offsetY = value;
                    break;
                case 'spreadDistance':
                    value = typeof rawBoxShadow.spreadDistance === 'string' ? parseLength(rawBoxShadow.spreadDistance) : rawBoxShadow.spreadDistance;
                    if (value == null) {
                        return [];
                    }
                    parsedBoxShadow.spreadDistance = value;
                    break;
                case 'blurRadius':
                    value = typeof rawBoxShadow.blurRadius === 'string' ? parseLength(rawBoxShadow.blurRadius) : rawBoxShadow.blurRadius;
                    if (value == null || value < 0) {
                        return [];
                    }
                    parsedBoxShadow.blurRadius = value;
                    break;
                case 'color':
                    var color = (0, _processColor.default)(rawBoxShadow.color);
                    if (color == null) {
                        return [];
                    }
                    parsedBoxShadow.color = color;
                    break;
                case 'inset':
                    parsedBoxShadow.inset = rawBoxShadow.inset;
            }
        }
        result.push(parsedBoxShadow);
    }
    return result;
}
function parseBoxShadowString(rawBoxShadows) {
    var result = [];
    for (var rawBoxShadow of rawBoxShadows.split(/,(?![^()]*\))/) // split by comma that is not in parenthesis
    .map((bS)=>bS.trim()).filter((bS)=>bS !== '')){
        var boxShadow = {
            offsetX: 0,
            offsetY: 0
        };
        var offsetX = void 0;
        var offsetY = void 0;
        var keywordDetectedAfterLength = false;
        var lengthCount = 0;
        // split rawBoxShadow string by all whitespaces that are not in parenthesis
        var args = rawBoxShadow.split(/\s+(?![^(]*\))/);
        for (var arg of args){
            var processedColor = (0, _processColor.default)(arg);
            if (processedColor != null) {
                if (boxShadow.color != null) {
                    return [];
                }
                if (offsetX != null) {
                    keywordDetectedAfterLength = true;
                }
                boxShadow.color = arg;
                continue;
            }
            if (arg === 'inset') {
                if (boxShadow.inset != null) {
                    return [];
                }
                if (offsetX != null) {
                    keywordDetectedAfterLength = true;
                }
                boxShadow.inset = true;
                continue;
            }
            switch(lengthCount){
                case 0:
                    offsetX = arg;
                    lengthCount++;
                    break;
                case 1:
                    if (keywordDetectedAfterLength) {
                        return [];
                    }
                    offsetY = arg;
                    lengthCount++;
                    break;
                case 2:
                    if (keywordDetectedAfterLength) {
                        return [];
                    }
                    boxShadow.blurRadius = arg;
                    lengthCount++;
                    break;
                case 3:
                    if (keywordDetectedAfterLength) {
                        return [];
                    }
                    boxShadow.spreadDistance = arg;
                    lengthCount++;
                    break;
                default:
                    return [];
            }
        }
        if (offsetX == null || offsetY == null) {
            return [];
        }
        boxShadow.offsetX = offsetX;
        boxShadow.offsetY = offsetY;
        result.push(boxShadow);
    }
    return result;
}
function parseLength(length) {
    // matches on args with units like "1.5 5% -80deg"
    var argsWithUnitsRegex = /([+-]?\d*(\.\d+)?)([\w\W]+)?/g;
    var match = argsWithUnitsRegex.exec(length);
    if (!match || Number.isNaN(match[1])) {
        return null;
    }
    if (match[3] != null && match[3] !== 'px') {
        return null;
    }
    return Number(match[1]);
}


}),
"./node_modules/react-native/Libraries/StyleSheet/processColor.js": 
/*!************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processColor.js ***!
  \************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var Platform = __webpack_require__(/*! ../Utilities/Platform */ "./node_modules/react-native/Libraries/Utilities/Platform.android.js");
var normalizeColor = __webpack_require__(/*! ./normalizeColor */ "./node_modules/react-native/Libraries/StyleSheet/normalizeColor.js");
/* eslint no-bitwise: 0 */ function processColor(color) {
    if (color === undefined || color === null) {
        return color;
    }
    var normalizedColor = normalizeColor(color);
    if (normalizedColor === null || normalizedColor === undefined) {
        return undefined;
    }
    if (typeof normalizedColor === 'object') {
        var processColorObject = (__webpack_require__(/*! ./PlatformColorValueTypes */ "./node_modules/react-native/Libraries/StyleSheet/PlatformColorValueTypes.android.js")/* .processColorObject */.processColorObject);
        var processedColorObj = processColorObject(normalizedColor);
        if (processedColorObj != null) {
            return processedColorObj;
        }
    }
    if (typeof normalizedColor !== 'number') {
        return null;
    }
    // Converts 0xrrggbbaa into 0xaarrggbb
    normalizedColor = (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;
    if (Platform.OS === 'android') {
        // Android use 32 bit *signed* integer to represent the color
        // We utilize the fact that bitwise operations in JS also operates on
        // signed 32 bit integers, so that we can use those to convert from
        // *unsigned* to *signed* 32bit int that way.
        normalizedColor = normalizedColor | 0x0;
    }
    return normalizedColor;
}
var _default = processColor;


}),
"./node_modules/react-native/Libraries/StyleSheet/processFilter.js": 
/*!*************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processFilter.js ***!
  \*************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format strict-local
 *      
 * @oncall react-native
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return processFilter;
    }
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _processColor = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./processColor */ "./node_modules/react-native/Libraries/StyleSheet/processColor.js"));
function processFilter(filter) {
    var result = [];
    if (filter == null) {
        return result;
    }
    if (typeof filter === 'string') {
        filter = filter.replace(/\n/g, ' ');
        // matches on functions with args and nested functions like "drop-shadow(10 10 10 rgba(0, 0, 0, 1))"
        var regex = /([\w-]+)\(([^()]*|\([^()]*\)|[^()]*\([^()]*\)[^()]*)\)/g;
        var matches;
        while(matches = regex.exec(filter)){
            var filterName = matches[1].toLowerCase();
            if (filterName === 'drop-shadow') {
                var dropShadow = parseDropShadow(matches[2]);
                if (dropShadow != null) {
                    result.push({
                        dropShadow
                    });
                } else {
                    return [];
                }
            } else {
                var camelizedName = filterName === 'drop-shadow' ? 'dropShadow' : filterName === 'hue-rotate' ? 'hueRotate' : filterName;
                var amount = _getFilterAmount(camelizedName, matches[2]);
                if (amount != null) {
                    var filterFunction = {};
                    // $FlowFixMe The key will be the correct one but flow can't see that.
                    filterFunction[camelizedName] = amount;
                    // $FlowFixMe The key will be the correct one but flow can't see that.
                    result.push(filterFunction);
                } else {
                    // If any primitive is invalid then apply none of the filters. This is how
                    // web works and makes it clear that something is wrong becuase no
                    // graphical effects are happening.
                    return [];
                }
            }
        }
    } else if (Array.isArray(filter)) {
        for (var filterFunction1 of filter){
            var _Object_entries_ = _sliced_to_array._(Object.entries(filterFunction1)[0], 2), filterName1 = _Object_entries_[0], filterValue = _Object_entries_[1];
            if (filterName1 === 'dropShadow') {
                // $FlowFixMe
                var dropShadow1 = parseDropShadow(filterValue);
                if (dropShadow1 == null) {
                    return [];
                }
                result.push({
                    dropShadow: dropShadow1
                });
            } else {
                var amount1 = _getFilterAmount(filterName1, filterValue);
                if (amount1 != null) {
                    var resultObject = {};
                    // $FlowFixMe
                    resultObject[filterName1] = amount1;
                    // $FlowFixMe
                    result.push(resultObject);
                } else {
                    // If any primitive is invalid then apply none of the filters. This is how
                    // web works and makes it clear that something is wrong becuase no
                    // graphical effects are happening.
                    return [];
                }
            }
        }
    } else {
        throw new TypeError(`${typeof filter} filter is not a string or array`);
    }
    return result;
}
function _getFilterAmount(filterName, filterArgs) {
    var filterArgAsNumber;
    var unit;
    if (typeof filterArgs === 'string') {
        // matches on args with units like "1.5 5% -80deg"
        var argsWithUnitsRegex = new RegExp(/([+-]?\d*(\.\d+)?)([a-zA-Z%]+)?/g);
        var match = argsWithUnitsRegex.exec(filterArgs);
        if (!match || isNaN(Number(match[1]))) {
            return undefined;
        }
        filterArgAsNumber = Number(match[1]);
        unit = match[3];
    } else if (typeof filterArgs === 'number') {
        filterArgAsNumber = filterArgs;
    } else {
        return undefined;
    }
    switch(filterName){
        // Hue rotate takes some angle that can have a unit and can be
        // negative. Additionally, 0 with no unit is allowed.
        case 'hueRotate':
            if (filterArgAsNumber === 0) {
                return 0;
            }
            if (unit !== 'deg' && unit !== 'rad') {
                return undefined;
            }
            return unit === 'rad' ? 180 * filterArgAsNumber / Math.PI : filterArgAsNumber;
        // blur takes any positive CSS length that is not a percent. In RN
        // we currently only have DIPs, so we are not parsing units here.
        case 'blur':
            if (unit && unit !== 'px' || filterArgAsNumber < 0) {
                return undefined;
            }
            return filterArgAsNumber;
        // All other filters except take a non negative number or percentage. There
        // are no units associated with this value and percentage numbers map 1-to-1
        // to a non-percentage number (e.g. 50% == 0.5).
        case 'brightness':
        case 'contrast':
        case 'grayscale':
        case 'invert':
        case 'opacity':
        case 'saturate':
        case 'sepia':
            if (unit && unit !== '%' && unit !== 'px' || filterArgAsNumber < 0) {
                return undefined;
            }
            if (unit === '%') {
                filterArgAsNumber /= 100;
            }
            return filterArgAsNumber;
        default:
            return undefined;
    }
}
function parseDropShadow(rawDropShadow) {
    var dropShadow = typeof rawDropShadow === 'string' ? parseDropShadowString(rawDropShadow) : rawDropShadow;
    var parsedDropShadow = {
        offsetX: 0,
        offsetY: 0
    };
    var offsetX;
    var offsetY;
    for(var arg in dropShadow){
        var value = void 0;
        switch(arg){
            case 'offsetX':
                value = typeof dropShadow.offsetX === 'string' ? parseLength(dropShadow.offsetX) : dropShadow.offsetX;
                if (value == null) {
                    return null;
                }
                offsetX = value;
                break;
            case 'offsetY':
                value = typeof dropShadow.offsetY === 'string' ? parseLength(dropShadow.offsetY) : dropShadow.offsetY;
                if (value == null) {
                    return null;
                }
                offsetY = value;
                break;
            case 'standardDeviation':
                value = typeof dropShadow.standardDeviation === 'string' ? parseLength(dropShadow.standardDeviation) : dropShadow.standardDeviation;
                if (value == null || value < 0) {
                    return null;
                }
                parsedDropShadow.standardDeviation = value;
                break;
            case 'color':
                var color = (0, _processColor.default)(dropShadow.color);
                if (color == null) {
                    return null;
                }
                parsedDropShadow.color = color;
                break;
            default:
                return null;
        }
    }
    if (offsetX == null || offsetY == null) {
        return null;
    }
    parsedDropShadow.offsetX = offsetX;
    parsedDropShadow.offsetY = offsetY;
    return parsedDropShadow;
}
function parseDropShadowString(rawDropShadow) {
    var dropShadow = {
        offsetX: 0,
        offsetY: 0
    };
    var offsetX;
    var offsetY;
    var lengthCount = 0;
    var keywordDetectedAfterLength = false;
    // split args by all whitespaces that are not in parenthesis
    for (var arg of rawDropShadow.split(/\s+(?![^(]*\))/)){
        var processedColor = (0, _processColor.default)(arg);
        if (processedColor != null) {
            if (dropShadow.color != null) {
                return null;
            }
            if (offsetX != null) {
                keywordDetectedAfterLength = true;
            }
            dropShadow.color = arg;
            continue;
        }
        switch(lengthCount){
            case 0:
                offsetX = arg;
                lengthCount++;
                break;
            case 1:
                if (keywordDetectedAfterLength) {
                    return null;
                }
                offsetY = arg;
                lengthCount++;
                break;
            case 2:
                if (keywordDetectedAfterLength) {
                    return null;
                }
                dropShadow.standardDeviation = arg;
                lengthCount++;
                break;
            default:
                return null;
        }
    }
    if (offsetX == null || offsetY == null) {
        return null;
    }
    dropShadow.offsetX = offsetX;
    dropShadow.offsetY = offsetY;
    return dropShadow;
}
function parseLength(length) {
    // matches on args with units like "1.5 5% -80deg"
    var argsWithUnitsRegex = /([+-]?\d*(\.\d+)?)([\w\W]+)?/g;
    var match = argsWithUnitsRegex.exec(length);
    if (!match || Number.isNaN(match[1])) {
        return null;
    }
    if (match[3] != null && match[3] !== 'px') {
        return null;
    }
    return Number(match[1]);
}


}),
"./node_modules/react-native/Libraries/StyleSheet/processFontVariant.js": 
/*!******************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processFontVariant.js ***!
  \******************************************************************************/
(function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict-local
 */ 
function processFontVariant(fontVariant) {
    if (Array.isArray(fontVariant)) {
        return fontVariant;
    }
    // $FlowFixMe[incompatible-type]
    var match = fontVariant.split(' ').filter(Boolean);
    return match;
}
module.exports = processFontVariant;


}),
"./node_modules/react-native/Libraries/StyleSheet/processTransform.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processTransform.js ***!
  \****************************************************************************/
(function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *      
 */ 
var stringifySafe = (__webpack_require__(/*! ../Utilities/stringifySafe */ "./node_modules/react-native/Libraries/Utilities/stringifySafe.js")/* ["default"] */["default"]);
var invariant = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
/**
 * Generate a transform matrix based on the provided transforms, and use that
 * within the style object instead.
 *
 * This allows us to provide an API that is similar to CSS, where transforms may
 * be applied in an arbitrary order, and yet have a universal, singular
 * interface to native code.
 */ function processTransform(transform) {
    if (typeof transform === 'string') {
        var regex = new RegExp(/(\w+)\(([^)]+)\)/g);
        var transformArray = [];
        var matches;
        while(matches = regex.exec(transform)){
            var _getKeyAndValueFromCSSTransform1 = _getKeyAndValueFromCSSTransform(matches[1], matches[2]), key = _getKeyAndValueFromCSSTransform1.key, value = _getKeyAndValueFromCSSTransform1.value;
            if (value !== undefined) {
                transformArray.push({
                    [key]: value
                });
            }
        }
        transform = transformArray;
    }
    if (true) {
        _validateTransforms(transform);
    }
    return transform;
}
var _getKeyAndValueFromCSSTransform = (key, args)=>{
    var argsWithUnitsRegex = new RegExp(/([+-]?\d+(\.\d+)?)([a-zA-Z]+|%)?/g);
    switch(key){
        case 'matrix':
            var _args_match;
            return {
                key,
                value: (_args_match = args.match(/[+-]?\d+(\.\d+)?/g)) === null || _args_match === void 0 ? void 0 : _args_match.map(Number)
            };
        case 'translate':
        case 'translate3d':
            var parsedArgs = [];
            var missingUnitOfMeasurement = false;
            var matches;
            while(matches = argsWithUnitsRegex.exec(args)){
                var value = Number(matches[1]);
                var unitOfMeasurement = matches[3];
                if (value !== 0 && !unitOfMeasurement) {
                    missingUnitOfMeasurement = true;
                }
                if (unitOfMeasurement === '%') {
                    parsedArgs.push(`${value}%`);
                } else {
                    parsedArgs.push(value);
                }
            }
            if (true) {
                invariant(!missingUnitOfMeasurement, `Transform with key ${key} must have units unless the provided value is 0, found %s`, `${key}(${args})`);
                if (key === 'translate') {
                    invariant((parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length) === 1 || (parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length) === 2, 'Transform with key translate must be an string with 1 or 2 parameters, found %s: %s', parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length, `${key}(${args})`);
                } else {
                    invariant((parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length) === 3, 'Transform with key translate3d must be an string with 3 parameters, found %s: %s', parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length, `${key}(${args})`);
                }
            }
            if ((parsedArgs === null || parsedArgs === void 0 ? void 0 : parsedArgs.length) === 1) {
                parsedArgs.push(0);
            }
            return {
                key: 'translate',
                value: parsedArgs
            };
        case 'translateX':
        case 'translateY':
        case 'perspective':
            var argMatches = argsWithUnitsRegex.exec(args);
            if (!(argMatches === null || argMatches === void 0 ? void 0 : argMatches.length)) {
                return {
                    key,
                    value: undefined
                };
            }
            var value1 = Number(argMatches[1]);
            var unitOfMeasurement1 = argMatches[3];
            if (true) {
                invariant(value1 === 0 || unitOfMeasurement1, `Transform with key ${key} must have units unless the provided value is 0, found %s`, `${key}(${args})`);
            }
            return {
                key,
                value: value1
            };
        default:
            return {
                key,
                value: !isNaN(args) ? Number(args) : args
            };
    }
};
function _validateTransforms(transform) {
    transform.forEach((transformation)=>{
        var keys = Object.keys(transformation);
        invariant(keys.length === 1, 'You must specify exactly one property per transform object. Passed properties: %s', stringifySafe(transformation));
        var key = keys[0];
        var value = transformation[key];
        if (key === 'matrix' && transform.length > 1) {
            console.error('When using a matrix transform, you must specify exactly one transform object. Passed transform: ' + stringifySafe(transform));
        }
        _validateTransform(key, value, transformation);
    });
}
function _validateTransform(key, value, transformation) {
    invariant(!value.getValue, 'You passed an Animated.Value to a normal component. ' + 'You need to wrap that component in an Animated. For example, ' + 'replace <View /> by <Animated.View />.');
    var multivalueTransforms = [
        'matrix',
        'translate'
    ];
    if (multivalueTransforms.indexOf(key) !== -1) {
        invariant(Array.isArray(value), 'Transform with key of %s must have an array as the value: %s', key, stringifySafe(transformation));
    }
    switch(key){
        case 'matrix':
            invariant(value.length === 9 || value.length === 16, 'Matrix transform must have a length of 9 (2d) or 16 (3d). ' + 'Provided matrix has a length of %s: %s', /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.84 was deployed. To
         * see the error, delete this comment and run Flow. */ value.length, stringifySafe(transformation));
            break;
        case 'translate':
            invariant(value.length === 2 || value.length === 3, 'Transform with key translate must be an array of length 2 or 3, found %s: %s', /* $FlowFixMe[prop-missing] (>=0.84.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.84 was deployed. To
         * see the error, delete this comment and run Flow. */ value.length, stringifySafe(transformation));
            break;
        case 'rotateX':
        case 'rotateY':
        case 'rotateZ':
        case 'rotate':
        case 'skewX':
        case 'skewY':
            invariant(typeof value === 'string', 'Transform with key of "%s" must be a string: %s', key, stringifySafe(transformation));
            invariant(value.indexOf('deg') > -1 || value.indexOf('rad') > -1, 'Rotate transform must be expressed in degrees (deg) or radians ' + '(rad): %s', stringifySafe(transformation));
            break;
        case 'perspective':
            invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
            invariant(value !== 0, 'Transform with key of "%s" cannot be zero: %s', key, stringifySafe(transformation));
            break;
        case 'translateX':
        case 'translateY':
            invariant(typeof value === 'number' || typeof value === 'string' && value.endsWith('%'), 'Transform with key of "%s" must be number or a percentage. Passed value: %s.', key, stringifySafe(transformation));
            break;
        case 'scale':
        case 'scaleX':
        case 'scaleY':
            invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));
            break;
        default:
            invariant(false, 'Invalid transform %s: %s', key, stringifySafe(transformation));
    }
}
module.exports = processTransform;


}),
"./node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js": 
/*!**********************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/StyleSheet/processTransformOrigin.js ***!
  \**********************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *      
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return processTransformOrigin;
    }
}));
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var INDEX_X = 0;
var INDEX_Y = 1;
var INDEX_Z = 2;
function processTransformOrigin(transformOrigin) {
    if (typeof transformOrigin === 'string') {
        var transformOriginString = transformOrigin;
        var regex = /(top|bottom|left|right|center|\d+(?:%|px)|0)/gi;
        var transformOriginArray = [
            '50%',
            '50%',
            0
        ];
        var index = INDEX_X;
        var matches;
        outer: while(matches = regex.exec(transformOriginString)){
            var nextIndex = index + 1;
            var value = matches[0];
            var valueLower = value.toLowerCase();
            switch(valueLower){
                case 'left':
                case 'right':
                    {
                        (0, _invariant.default)(index === INDEX_X, 'Transform-origin %s can only be used for x-position', value);
                        transformOriginArray[INDEX_X] = valueLower === 'left' ? 0 : '100%';
                        break;
                    }
                case 'top':
                case 'bottom':
                    {
                        (0, _invariant.default)(index !== INDEX_Z, 'Transform-origin %s can only be used for y-position', value);
                        transformOriginArray[INDEX_Y] = valueLower === 'top' ? 0 : '100%';
                        // Handle [[ center | left | right ] && [ center | top | bottom ]] <length>?
                        if (index === INDEX_X) {
                            var horizontal = regex.exec(transformOriginString);
                            if (horizontal == null) {
                                break outer;
                            }
                            switch(horizontal[0].toLowerCase()){
                                case 'left':
                                    transformOriginArray[INDEX_X] = 0;
                                    break;
                                case 'right':
                                    transformOriginArray[INDEX_X] = '100%';
                                    break;
                                case 'center':
                                    transformOriginArray[INDEX_X] = '50%';
                                    break;
                                default:
                                    (0, _invariant.default)(false, 'Could not parse transform-origin: %s', transformOriginString);
                            }
                            nextIndex = INDEX_Z;
                        }
                        break;
                    }
                case 'center':
                    {
                        (0, _invariant.default)(index !== INDEX_Z, 'Transform-origin value %s cannot be used for z-position', value);
                        transformOriginArray[index] = '50%';
                        break;
                    }
                default:
                    {
                        if (value.endsWith('%')) {
                            transformOriginArray[index] = value;
                        } else {
                            transformOriginArray[index] = parseFloat(value); // Remove `px`
                        }
                        break;
                    }
            }
            index = nextIndex;
        }
        transformOrigin = transformOriginArray;
    }
    if (true) {
        _validateTransformOrigin(transformOrigin);
    }
    return transformOrigin;
}
function _validateTransformOrigin(transformOrigin) {
    (0, _invariant.default)(transformOrigin.length === 3, 'Transform origin must have exactly 3 values.');
    var _transformOrigin = _sliced_to_array._(transformOrigin, 3), x = _transformOrigin[0], y = _transformOrigin[1], z = _transformOrigin[2];
    (0, _invariant.default)(typeof x === 'number' || typeof x === 'string' && x.endsWith('%'), 'Transform origin x-position must be a number. Passed value: %s.', x);
    (0, _invariant.default)(typeof y === 'number' || typeof y === 'string' && y.endsWith('%'), 'Transform origin y-position must be a number. Passed value: %s.', y);
    (0, _invariant.default)(typeof z === 'number', 'Transform origin z-position must be a number. Passed value: %s.', z);
}


}),
"./node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js": 
/*!*****************************************************************************!*\
  !*** ./node_modules/react-native/Libraries/Utilities/differ/sizesDiffer.js ***!
  \*****************************************************************************/
(function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ 
var dummySize = {
    width: undefined,
    height: undefined
};
var sizesDiffer = function(one, two) {
    var defaultedOne = one || dummySize;
    var defaultedTwo = two || dummySize;
    return defaultedOne !== defaultedTwo && (defaultedOne.width !== defaultedTwo.width || defaultedOne.height !== defaultedTwo.height);
};
module.exports = sizesDiffer;


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native_Libraries_Components_View_ReactNativeStyleAttributes_js.chunk.bundle.map?platform=android