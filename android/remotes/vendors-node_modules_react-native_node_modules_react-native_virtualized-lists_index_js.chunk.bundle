(self["webpackChunksataccommodation"] = self["webpackChunksataccommodation"] || []).push([["vendors-node_modules_react-native_node_modules_react-native_virtualized-lists_index_js"], {
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js": 
/*!***********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js ***!
  \***********************************************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _reactnative = __webpack_require__(/*! react-native */ "webpack/sharing/consume/default/react-native/react-native?36cc");
var _ReactNativeFeatureFlags = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react-native/src/private/featureflags/ReactNativeFeatureFlags */ "webpack/sharing/consume/default/react-native/src/private/featureflags/ReactNativeFeatureFlags/react-native/src/private/featureflags/ReactNativeFeatureFlags"));
/**
 * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
 * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
 * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
 * interactions are done running.
 *
 * Make sure to cleanup with dispose().  Example:
 *
 *   class Widget extends React.Component {
 *     _batchedSave: new Batchinator(() => this._saveState, 1000);
 *     _saveSate() {
 *       // save this.state to disk
 *     }
 *     componentDidUpdate() {
 *       this._batchedSave.schedule();
 *     }
 *     componentWillUnmount() {
 *       this._batchedSave.dispose();
 *     }
 *     ...
 *   }
 */ var Batchinator = /*#__PURE__*/ function() {
    "use strict";
    function Batchinator(callback, delay) {
        _class_call_check._(this, Batchinator);
        this._delay = delay;
        this._callback = callback;
    }
    _create_class._(Batchinator, [
        {
            /*
   * Cleanup any pending tasks.
   *
   * By default, if there is a pending task the callback is run immediately. Set the option abort to
   * true to not call the callback if it was pending.
   */ key: "dispose",
            value: function dispose() {
                if (this._taskHandle) {
                    this._taskHandle.cancel();
                    this._taskHandle = null;
                }
            }
        },
        {
            key: "schedule",
            value: function schedule() {
                if (this._taskHandle) {
                    return;
                }
                var invokeCallback = ()=>{
                    // Note that we clear the handle before invoking the callback so that if the callback calls
                    // schedule again, it will actually schedule another task.
                    this._taskHandle = null;
                    this._callback();
                };
                var timeoutHandle = setTimeout(// NOTE: When shipping this, delete `Batchinator` instead of only these
                // lines of code. Without `InteractionManager`, it's just a `setTimeout`.
                _ReactNativeFeatureFlags.disableInteractionManagerInBatchinator() ? invokeCallback : ()=>{
                    this._taskHandle = _reactnative.InteractionManager.runAfterInteractions(invokeCallback);
                }, this._delay);
                this._taskHandle = {
                    cancel: ()=>clearTimeout(timeoutHandle)
                };
            }
        }
    ]);
    return Batchinator;
}();
module.exports = Batchinator;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js": 
/*!********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js ***!
  \********************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "CellRenderMask", ({
    enumerable: true,
    get: function() {
        return CellRenderMask;
    }
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var CellRenderMask = /*#__PURE__*/ function() {
    "use strict";
    function CellRenderMask(numCells) {
        _class_call_check._(this, CellRenderMask);
        (0, _invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
        this._numCells = numCells;
        if (numCells === 0) {
            this._regions = [];
        } else {
            this._regions = [
                {
                    first: 0,
                    last: numCells - 1,
                    isSpacer: true
                }
            ];
        }
    }
    _create_class._(CellRenderMask, [
        {
            key: "enumerateRegions",
            value: function enumerateRegions() {
                return this._regions;
            }
        },
        {
            key: "addCells",
            value: function addCells(cells) {
                var _this__regions;
                (0, _invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');
                // VirtualizedList uses inclusive ranges, where zero-count states are
                // possible. E.g. [0, -1] for no cells, starting at 0.
                if (cells.last < cells.first) {
                    return;
                }
                var _this__findRegion = _sliced_to_array._(this._findRegion(cells.first), 2), firstIntersect = _this__findRegion[0], firstIntersectIdx = _this__findRegion[1];
                var _this__findRegion1 = _sliced_to_array._(this._findRegion(cells.last), 2), lastIntersect = _this__findRegion1[0], lastIntersectIdx = _this__findRegion1[1];
                // Fast-path if the cells to add are already all present in the mask. We
                // will otherwise need to do some mutation.
                if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
                    return;
                }
                // We need to replace the existing covered regions with 1-3 new regions
                // depending whether we need to split spacers out of overlapping regions.
                var newLeadRegion = [];
                var newTailRegion = [];
                var newMainRegion = _object_spread_props._(_object_spread._({}, cells), {
                    isSpacer: false
                });
                if (firstIntersect.first < newMainRegion.first) {
                    if (firstIntersect.isSpacer) {
                        newLeadRegion.push({
                            first: firstIntersect.first,
                            last: newMainRegion.first - 1,
                            isSpacer: true
                        });
                    } else {
                        newMainRegion.first = firstIntersect.first;
                    }
                }
                if (lastIntersect.last > newMainRegion.last) {
                    if (lastIntersect.isSpacer) {
                        newTailRegion.push({
                            first: newMainRegion.last + 1,
                            last: lastIntersect.last,
                            isSpacer: true
                        });
                    } else {
                        newMainRegion.last = lastIntersect.last;
                    }
                }
                var replacementRegions = _to_consumable_array._(newLeadRegion).concat([
                    newMainRegion
                ], _to_consumable_array._(newTailRegion));
                var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
                (_this__regions = this._regions).splice.apply(_this__regions, [
                    firstIntersectIdx,
                    numRegionsToDelete
                ].concat(_to_consumable_array._(replacementRegions)));
            }
        },
        {
            key: "numCells",
            value: function numCells() {
                return this._numCells;
            }
        },
        {
            key: "equals",
            value: function equals(other) {
                return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i)=>region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
            }
        },
        {
            key: "_findRegion",
            value: function _findRegion(cellIdx) {
                var firstIdx = 0;
                var lastIdx = this._regions.length - 1;
                while(firstIdx <= lastIdx){
                    var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
                    var middleRegion = this._regions[middleIdx];
                    if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
                        return [
                            middleRegion,
                            middleIdx
                        ];
                    } else if (cellIdx < middleRegion.first) {
                        lastIdx = middleIdx - 1;
                    } else if (cellIdx > middleRegion.last) {
                        firstIdx = middleIdx + 1;
                    }
                }
                (0, _invariant.default)(false, `A region was not found containing cellIdx ${cellIdx}`);
            }
        }
    ]);
    return CellRenderMask;
}();


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js": 
/*!*************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js ***!
  \*************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return ChildListCollection;
    }
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var ChildListCollection = /*#__PURE__*/ function() {
    "use strict";
    function ChildListCollection() {
        _class_call_check._(this, ChildListCollection);
        this._cellKeyToChildren = new Map();
        this._childrenToCellKey = new Map();
    }
    _create_class._(ChildListCollection, [
        {
            key: "add",
            value: function add(list, cellKey) {
                (0, _invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
                var cellLists = this._cellKeyToChildren.get(cellKey) ?? new Set();
                cellLists.add(list);
                this._cellKeyToChildren.set(cellKey, cellLists);
                this._childrenToCellKey.set(list, cellKey);
            }
        },
        {
            key: "remove",
            value: function remove(list) {
                var cellKey = this._childrenToCellKey.get(list);
                (0, _invariant.default)(cellKey != null, 'Trying to remove non-present child list');
                this._childrenToCellKey.delete(list);
                var cellLists = this._cellKeyToChildren.get(cellKey);
                (0, _invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
                cellLists.delete(list);
                if (cellLists.size === 0) {
                    this._cellKeyToChildren.delete(cellKey);
                }
            }
        },
        {
            key: "forEach",
            value: function forEach(fn) {
                for (var listSet of this._cellKeyToChildren.values()){
                    for (var list of listSet){
                        fn(list);
                    }
                }
            }
        },
        {
            key: "forEachInCell",
            value: function forEachInCell(cellKey, fn) {
                var listSet = this._cellKeyToChildren.get(cellKey) ?? [];
                for (var list of listSet){
                    fn(list);
                }
            }
        },
        {
            key: "anyInCell",
            value: function anyInCell(cellKey, fn) {
                var listSet = this._cellKeyToChildren.get(cellKey) ?? [];
                for (var list of listSet){
                    if (fn(list)) {
                        return true;
                    }
                }
                return false;
            }
        },
        {
            key: "size",
            value: function size() {
                return this._childrenToCellKey.size;
            }
        }
    ]);
    return ChildListCollection;
}();


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js": 
/*!********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js ***!
  \********************************************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ListMetricsAggregator */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"));
var Info = function Info() {
    _class_call_check._(this, Info);
    this.any_blank_count = 0;
    this.any_blank_ms = 0;
    this.any_blank_speed_sum = 0;
    this.mostly_blank_count = 0;
    this.mostly_blank_ms = 0;
    this.pixels_blank = 0;
    this.pixels_sampled = 0;
    this.pixels_scrolled = 0;
    this.total_time_spent = 0;
    this.sample_count = 0;
};
var DEBUG = false;
var _listeners = [];
var _minSampleCount = 10;
var _sampleRate = DEBUG ? 1 : null;
/**
 * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
 * By default the sampling rate is set to zero and this will do nothing. If you want to collect
 * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
 *
 * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
 * `SceneTracker.getActiveScene` to determine the context of the events.
 */ var FillRateHelper = /*#__PURE__*/ function() {
    function FillRateHelper(listMetrics) {
        _class_call_check._(this, FillRateHelper);
        this._anyBlankStartTime = null;
        this._enabled = false;
        this._info = new Info();
        this._mostlyBlankStartTime = null;
        this._samplesStartTime = null;
        this._listMetrics = listMetrics;
        this._enabled = (_sampleRate || 0) > Math.random();
        this._resetData();
    }
    _create_class._(FillRateHelper, [
        {
            key: "activate",
            value: function activate() {
                if (this._enabled && this._samplesStartTime == null) {
                    DEBUG && console.debug('FillRateHelper: activate');
                    this._samplesStartTime = __webpack_require__.g.performance.now();
                }
            }
        },
        {
            key: "deactivateAndFlush",
            value: function deactivateAndFlush() {
                if (!this._enabled) {
                    return;
                }
                var start = this._samplesStartTime; // const for flow
                if (start == null) {
                    DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');
                    return;
                }
                if (this._info.sample_count < _minSampleCount) {
                    // Don't bother with under-sampled events.
                    this._resetData();
                    return;
                }
                var total_time_spent = __webpack_require__.g.performance.now() - start;
                var info = _object_spread_props._(_object_spread._({}, this._info), {
                    total_time_spent
                });
                if (DEBUG) {
                    var derived = {
                        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,
                        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),
                        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,
                        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),
                        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,
                        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),
                        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent
                    };
                    for(var key in derived){
                        // $FlowFixMe[prop-missing]
                        // $FlowFixMe[invalid-computed-prop]
                        derived[key] = Math.round(1000 * derived[key]) / 1000;
                    }
                    console.debug('FillRateHelper deactivateAndFlush: ', {
                        derived,
                        info
                    });
                }
                _listeners.forEach((listener)=>listener(info));
                this._resetData();
            }
        },
        {
            key: "computeBlankness",
            value: function computeBlankness(props, cellsAroundViewport, scrollMetrics) {
                if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
                    return 0;
                }
                var dOffset = scrollMetrics.dOffset, offset = scrollMetrics.offset, velocity = scrollMetrics.velocity, visibleLength = scrollMetrics.visibleLength;
                // Denominator metrics that we track for all events - most of the time there is no blankness and
                // we want to capture that.
                this._info.sample_count++;
                this._info.pixels_sampled += Math.round(visibleLength);
                this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
                var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec
                // Whether blank now or not, record the elapsed time blank if we were blank last time.
                var now = __webpack_require__.g.performance.now();
                if (this._anyBlankStartTime != null) {
                    this._info.any_blank_ms += now - this._anyBlankStartTime;
                }
                this._anyBlankStartTime = null;
                if (this._mostlyBlankStartTime != null) {
                    this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
                }
                this._mostlyBlankStartTime = null;
                var blankTop = 0;
                var first = cellsAroundViewport.first;
                var firstFrame = this._listMetrics.getCellMetrics(first, props);
                while(first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.isMounted)){
                    firstFrame = this._listMetrics.getCellMetrics(first, props);
                    first++;
                }
                // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
                // as blank.
                if (firstFrame && first > 0) {
                    blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
                }
                var blankBottom = 0;
                var last = cellsAroundViewport.last;
                var lastFrame = this._listMetrics.getCellMetrics(last, props);
                while(last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.isMounted)){
                    lastFrame = this._listMetrics.getCellMetrics(last, props);
                    last--;
                }
                // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
                // footer as blank.
                if (lastFrame && last < props.getItemCount(props.data) - 1) {
                    var bottomEdge = lastFrame.offset + lastFrame.length;
                    blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
                }
                var pixels_blank = Math.round(blankTop + blankBottom);
                var blankness = pixels_blank / visibleLength;
                if (blankness > 0) {
                    this._anyBlankStartTime = now;
                    this._info.any_blank_speed_sum += scrollSpeed;
                    this._info.any_blank_count++;
                    this._info.pixels_blank += pixels_blank;
                    if (blankness > 0.5) {
                        this._mostlyBlankStartTime = now;
                        this._info.mostly_blank_count++;
                    }
                } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
                    this.deactivateAndFlush();
                }
                return blankness;
            }
        },
        {
            key: "enabled",
            value: function enabled() {
                return this._enabled;
            }
        },
        {
            key: "_resetData",
            value: function _resetData() {
                this._anyBlankStartTime = null;
                this._info = new Info();
                this._mostlyBlankStartTime = null;
                this._samplesStartTime = null;
            }
        }
    ], [
        {
            key: "addListener",
            value: function addListener(callback) {
                if (_sampleRate === null) {
                    console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
                }
                _listeners.push(callback);
                return {
                    remove: ()=>{
                        _listeners = _listeners.filter((listener)=>callback !== listener);
                    }
                };
            }
        },
        {
            key: "setSampleRate",
            value: function setSampleRate(sampleRate) {
                _sampleRate = sampleRate;
            }
        },
        {
            key: "setMinSampleCount",
            value: function setMinSampleCount(minSampleCount) {
                _minSampleCount = minSampleCount;
            }
        }
    ]);
    return FillRateHelper;
}();
module.exports = FillRateHelper;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js": 
/*!***************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js ***!
  \***************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return ListMetricsAggregator;
    }
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _VirtualizeUtils = __webpack_require__(/*! ./VirtualizeUtils */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var ListMetricsAggregator = /*#__PURE__*/ function() {
    "use strict";
    function ListMetricsAggregator() {
        _class_call_check._(this, ListMetricsAggregator);
        this._averageCellLength = 0;
        this._cellMetrics = new Map();
        this._highestMeasuredCellIndex = 0;
        this._measuredCellsLength = 0;
        this._measuredCellsCount = 0;
        this._orientation = {
            horizontal: false,
            rtl: false
        };
    }
    _create_class._(ListMetricsAggregator, [
        {
            /**
   * Notify the ListMetricsAggregator that a cell has been laid out.
   *
   * @returns whether the cell layout has changed since last notification
   */ key: "notifyCellLayout",
            value: function notifyCellLayout(ref) {
                var cellIndex = ref.cellIndex, cellKey = ref.cellKey, orientation = ref.orientation, layout = ref.layout;
                this._invalidateIfOrientationChanged(orientation);
                var next = {
                    index: cellIndex,
                    length: this._selectLength(layout),
                    isMounted: true,
                    offset: this.flowRelativeOffset(layout)
                };
                var curr = this._cellMetrics.get(cellKey);
                if (!curr || next.offset !== curr.offset || next.length !== curr.length) {
                    if (curr) {
                        var dLength = next.length - curr.length;
                        this._measuredCellsLength += dLength;
                    } else {
                        this._measuredCellsLength += next.length;
                        this._measuredCellsCount += 1;
                    }
                    this._averageCellLength = this._measuredCellsLength / this._measuredCellsCount;
                    this._cellMetrics.set(cellKey, next);
                    this._highestMeasuredCellIndex = Math.max(this._highestMeasuredCellIndex, cellIndex);
                    return true;
                } else {
                    curr.isMounted = true;
                    return false;
                }
            }
        },
        {
            /**
   * Notify ListMetricsAggregator that a cell has been unmounted.
   */ key: "notifyCellUnmounted",
            value: function notifyCellUnmounted(cellKey) {
                var curr = this._cellMetrics.get(cellKey);
                if (curr) {
                    curr.isMounted = false;
                }
            }
        },
        {
            /**
   * Notify ListMetricsAggregator that the lists content container has been laid out.
   */ key: "notifyListContentLayout",
            value: function notifyListContentLayout(ref) {
                var orientation = ref.orientation, layout = ref.layout;
                this._invalidateIfOrientationChanged(orientation);
                this._contentLength = this._selectLength(layout);
            }
        },
        {
            /**
   * Return the average length of the cells which have been measured
   */ key: "getAverageCellLength",
            value: function getAverageCellLength() {
                return this._averageCellLength;
            }
        },
        {
            /**
   * Return the highest measured cell index (or 0 if nothing has been measured
   * yet)
   */ key: "getHighestMeasuredCellIndex",
            value: function getHighestMeasuredCellIndex() {
                return this._highestMeasuredCellIndex;
            }
        },
        {
            /**
   * Returns the exact metrics of a cell if it has already been laid out,
   * otherwise an estimate based on the average length of previously measured
   * cells
   */ key: "getCellMetricsApprox",
            value: function getCellMetricsApprox(index, props) {
                var frame = this.getCellMetrics(index, props);
                if (frame && frame.index === index) {
                    // check for invalid frames due to row re-ordering
                    return frame;
                } else {
                    var offset;
                    var highestMeasuredCellIndex = this.getHighestMeasuredCellIndex();
                    if (highestMeasuredCellIndex < index) {
                        // If any of the cells before this one have been laid out already, we
                        // should use that information in the estimations.
                        // This is important because if the list has a header, the initial cell
                        // will have a larger offset that we should take into account here.
                        var highestMeasuredCellFrame = this.getCellMetrics(highestMeasuredCellIndex, props);
                        if (highestMeasuredCellFrame) {
                            offset = highestMeasuredCellFrame.offset + highestMeasuredCellFrame.length + this._averageCellLength * (index - highestMeasuredCellIndex - 1);
                        }
                    }
                    if (offset == null) {
                        offset = this._averageCellLength * index;
                    }
                    var data = props.data, getItemCount = props.getItemCount;
                    (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
                    return {
                        length: this._averageCellLength,
                        offset,
                        index,
                        isMounted: false
                    };
                }
            }
        },
        {
            /**
   * Returns the exact metrics of a cell if it has already been laid out
   */ key: "getCellMetrics",
            value: function getCellMetrics(index, props) {
                var data = props.data, getItem = props.getItem, getItemCount = props.getItemCount, getItemLayout = props.getItemLayout;
                (0, _invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get metrics for out of range cell index ' + index);
                var keyExtractor = props.keyExtractor ?? _VirtualizeUtils.keyExtractor;
                var frame = this._cellMetrics.get(keyExtractor(getItem(data, index), index));
                if (frame && frame.index === index) {
                    return frame;
                }
                if (getItemLayout) {
                    var _getItemLayout = getItemLayout(data, index), length = _getItemLayout.length, offset = _getItemLayout.offset;
                    // TODO: `isMounted` is used for both "is exact layout" and "has been
                    // unmounted". Should be refactored.
                    return {
                        index,
                        length,
                        offset,
                        isMounted: true
                    };
                }
                return null;
            }
        },
        {
            /**
   * Gets an approximate offset to an item at a given index. Supports
   * fractional indices.
   */ key: "getCellOffsetApprox",
            value: function getCellOffsetApprox(index, props) {
                if (Number.isInteger(index)) {
                    return this.getCellMetricsApprox(index, props).offset;
                } else {
                    var frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);
                    var remainder = index - Math.floor(index);
                    return frameMetrics.offset + remainder * frameMetrics.length;
                }
            }
        },
        {
            /**
   * Returns the length of all ScrollView content along the scrolling axis.
   */ key: "getContentLength",
            value: function getContentLength() {
                return this._contentLength ?? 0;
            }
        },
        {
            /**
   * Whether a content length has been observed
   */ key: "hasContentLength",
            value: function hasContentLength() {
                return this._contentLength != null;
            }
        },
        {
            /**
   * Finds the flow-relative offset (e.g. starting from the left in LTR, but
   * right in RTL) from a layout box.
   */ key: "flowRelativeOffset",
            value: function flowRelativeOffset(layout, referenceContentLength) {
                var _this__orientation = this._orientation, horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
                if (horizontal && rtl) {
                    var contentLength = referenceContentLength ?? this._contentLength;
                    (0, _invariant.default)(contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');
                    return contentLength - (this._selectOffset(layout) + this._selectLength(layout));
                } else {
                    return this._selectOffset(layout);
                }
            }
        },
        {
            /**
   * Converts a flow-relative offset to a cartesian offset
   */ key: "cartesianOffset",
            value: function cartesianOffset(flowRelativeOffset) {
                var _this__orientation = this._orientation, horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
                if (horizontal && rtl) {
                    (0, _invariant.default)(this._contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');
                    return this._contentLength - flowRelativeOffset;
                } else {
                    return flowRelativeOffset;
                }
            }
        },
        {
            key: "_invalidateIfOrientationChanged",
            value: function _invalidateIfOrientationChanged(orientation) {
                if (orientation.rtl !== this._orientation.rtl) {
                    this._cellMetrics.clear();
                }
                if (orientation.horizontal !== this._orientation.horizontal) {
                    this._averageCellLength = 0;
                    this._highestMeasuredCellIndex = 0;
                    this._measuredCellsLength = 0;
                    this._measuredCellsCount = 0;
                }
                this._orientation = orientation;
            }
        },
        {
            key: "_selectLength",
            value: function _selectLength(ref) {
                var width = ref.width, height = ref.height;
                return this._orientation.horizontal ? width : height;
            }
        },
        {
            key: "_selectOffset",
            value: function _selectOffset(ref) {
                var x = ref.x, y = ref.y;
                return this._orientation.horizontal ? x : y;
            }
        }
    ]);
    return ListMetricsAggregator;
}();


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js": 
/*!****************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js ***!
  \****************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return StateSafePureComponent;
    }
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _get = __webpack_require__(/*! @swc/helpers/_/_get */ "./node_modules/@swc/helpers/cjs/_get.cjs");
var _get_prototype_of = __webpack_require__(/*! @swc/helpers/_/_get_prototype_of */ "./node_modules/@swc/helpers/cjs/_get_prototype_of.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
var StateSafePureComponent = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(StateSafePureComponent, _React_PureComponent);
    function StateSafePureComponent(props) {
        _class_call_check._(this, StateSafePureComponent);
        var _this;
        _this = _call_super._(this, StateSafePureComponent, [
            props
        ]), _this._inAsyncStateUpdate = false;
        _this._installSetStateHooks();
        return _this;
    }
    _create_class._(StateSafePureComponent, [
        {
            key: "setState",
            value: function setState(partialState, callback) {
                if (typeof partialState === 'function') {
                    _get._(_get_prototype_of._(StateSafePureComponent.prototype), "setState", this).call(this, (state, props)=>{
                        this._inAsyncStateUpdate = true;
                        var ret;
                        try {
                            ret = partialState(state, props);
                        } catch (err) {
                            throw err;
                        } finally{
                            this._inAsyncStateUpdate = false;
                        }
                        return ret;
                    }, callback);
                } else {
                    _get._(_get_prototype_of._(StateSafePureComponent.prototype), "setState", this).call(this, partialState, callback);
                }
            }
        },
        {
            key: "_installSetStateHooks",
            value: function _installSetStateHooks() {
                var that = this;
                var _this = this, props = _this.props, state = _this.state;
                Object.defineProperty(this, 'props', {
                    get () {
                        (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
                        return props;
                    },
                    set (newProps) {
                        props = newProps;
                    }
                });
                Object.defineProperty(this, 'state', {
                    get () {
                        (0, _invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
                        return state;
                    },
                    set (newState) {
                        state = newState;
                    }
                });
            }
        }
    ]);
    return StateSafePureComponent;
}(_react.PureComponent);


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js": 
/*!***********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js ***!
  \***********************************************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ListMetricsAggregator */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"));
var invariant = __webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js");
/**
 * A Utility class for calculating viewable items based on current metrics like scroll position and
 * layout.
 *
 * An item is said to be in a "viewable" state when any of the following
 * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
 * is true):
 *
 * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
 *   visible in the view area >= `itemVisiblePercentThreshold`.
 * - Entirely visible on screen
 */ var ViewabilityHelper = /*#__PURE__*/ function() {
    function ViewabilityHelper(ref) {
        var config = ref === void 0 ? {
            viewAreaCoveragePercentThreshold: 0
        } : ref;
        _class_call_check._(this, ViewabilityHelper);
        this._hasInteracted = false;
        this._timers = new Set();
        this._viewableIndices = [];
        this._viewableItems = new Map();
        this._config = config;
    }
    _create_class._(ViewabilityHelper, [
        {
            /**
   * Cleanup, e.g. on unmount. Clears any pending timers.
   */ key: "dispose",
            value: function dispose() {
                /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
     * comment suppresses an error found when Flow v0.63 was deployed. To see
     * the error delete this comment and run Flow. */ this._timers.forEach(clearTimeout);
            }
        },
        {
            /**
   * Determines which items are viewable based on the current metrics and config.
   */ key: "computeViewableItems",
            value: function computeViewableItems(props, scrollOffset, viewportHeight, listMetrics, // Optional optimization to reduce the scan size
            renderRange) {
                var itemCount = props.getItemCount(props.data);
                var _this__config = this._config, itemVisiblePercentThreshold = _this__config.itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold = _this__config.viewAreaCoveragePercentThreshold;
                var viewAreaMode = viewAreaCoveragePercentThreshold != null;
                var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
                invariant(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
                var viewableIndices = [];
                if (itemCount === 0) {
                    return viewableIndices;
                }
                var firstVisible = -1;
                var _ref = renderRange || {
                    first: 0,
                    last: itemCount - 1
                }, first = _ref.first, last = _ref.last;
                if (last >= itemCount) {
                    console.warn('Invalid render range computing viewability ' + JSON.stringify({
                        renderRange,
                        itemCount
                    }));
                    return [];
                }
                for(var idx = first; idx <= last; idx++){
                    var metrics = listMetrics.getCellMetrics(idx, props);
                    if (!metrics) {
                        continue;
                    }
                    var top = Math.floor(metrics.offset - scrollOffset);
                    var bottom = Math.floor(top + metrics.length);
                    if (top < viewportHeight && bottom > 0) {
                        firstVisible = idx;
                        if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
                            viewableIndices.push(idx);
                        }
                    } else if (firstVisible >= 0) {
                        break;
                    }
                }
                return viewableIndices;
            }
        },
        {
            /**
   * Figures out which items are viewable and how that has changed from before and calls
   * `onViewableItemsChanged` as appropriate.
   */ key: "onUpdate",
            value: function onUpdate(props, scrollOffset, viewportHeight, listMetrics, createViewToken, onViewableItemsChanged, // Optional optimization to reduce the scan size
            renderRange) {
                var itemCount = props.getItemCount(props.data);
                if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !listMetrics.getCellMetrics(0, props)) {
                    return;
                }
                var viewableIndices = [];
                if (itemCount) {
                    viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, listMetrics, renderRange);
                }
                if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii)=>v === viewableIndices[ii])) {
                    // We might get a lot of scroll events where visibility doesn't change and we don't want to do
                    // extra work in those cases.
                    return;
                }
                this._viewableIndices = viewableIndices;
                if (this._config.minimumViewTime) {
                    var handle = setTimeout(()=>{
                        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To
         * see the error delete this comment and run Flow. */ this._timers.delete(handle);
                        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
                    }, this._config.minimumViewTime);
                    /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.63 was deployed. To see
       * the error delete this comment and run Flow. */ this._timers.add(handle);
                } else {
                    this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
                }
            }
        },
        {
            /**
   * clean-up cached _viewableIndices to evaluate changed items on next update
   */ key: "resetViewableIndices",
            value: function resetViewableIndices() {
                this._viewableIndices = [];
            }
        },
        {
            /**
   * Records that an interaction has happened even if there has been no scroll.
   */ key: "recordInteraction",
            value: function recordInteraction() {
                this._hasInteracted = true;
            }
        },
        {
            key: "_onUpdateSync",
            value: function _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
                // Filter out indices that have gone out of view since this call was scheduled.
                viewableIndicesToCheck = viewableIndicesToCheck.filter((ii)=>this._viewableIndices.includes(ii));
                var prevItems = this._viewableItems;
                var nextItems = new Map(viewableIndicesToCheck.map((ii)=>{
                    var viewable = createViewToken(ii, true, props);
                    return [
                        viewable.key,
                        viewable
                    ];
                }));
                var changed = [];
                for (var ref of nextItems){
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], viewable = _ref[1];
                    if (!prevItems.has(key)) {
                        changed.push(viewable);
                    }
                }
                for (var ref1 of prevItems){
                    var _ref1 = _sliced_to_array._(ref1, 2), key1 = _ref1[0], viewable1 = _ref1[1];
                    if (!nextItems.has(key1)) {
                        changed.push(_object_spread_props._(_object_spread._({}, viewable1), {
                            isViewable: false
                        }));
                    }
                }
                if (changed.length > 0) {
                    this._viewableItems = nextItems;
                    onViewableItemsChanged({
                        viewableItems: Array.from(nextItems.values()),
                        changed,
                        viewabilityConfig: this._config
                    });
                }
            }
        }
    ]);
    return ViewabilityHelper;
}();
function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
        return true;
    } else {
        var pixels = _getPixelsVisible(top, bottom, viewportHeight);
        var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
        return percent >= viewablePercentThreshold;
    }
}
function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
}
function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
}
module.exports = ViewabilityHelper;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js": 
/*!*********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js ***!
  \*********************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get computeWindowedRenderLimits () {
        return computeWindowedRenderLimits;
    },
    get elementsThatOverlapOffsets () {
        return elementsThatOverlapOffsets;
    },
    get keyExtractor () {
        return keyExtractor;
    },
    get newRangeCount () {
        return newRangeCount;
    }
});
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _ReactNativeFeatureFlags = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react-native/src/private/featureflags/ReactNativeFeatureFlags */ "webpack/sharing/consume/default/react-native/src/private/featureflags/ReactNativeFeatureFlags/react-native/src/private/featureflags/ReactNativeFeatureFlags"));
function elementsThatOverlapOffsets(offsets, props, listMetrics, ref) {
    var zoomScale = ref === void 0 ? 1 : ref;
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for(var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++){
        var currentOffset = offsets[offsetIndex];
        var left = 0;
        var right = itemCount - 1;
        while(left <= right){
            var mid = left + Math.floor((right - left) / 2);
            var frame = listMetrics.getCellMetricsApprox(mid, props);
            var scaledOffsetStart = frame.offset * zoomScale;
            var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;
            // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
            // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
            if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
                right = mid - 1;
            } else if (currentOffset > scaledOffsetEnd) {
                left = mid + 1;
            } else {
                result[offsetIndex] = mid;
                break;
            }
        }
    }
    return result;
}
function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
}
function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, listMetrics, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
        return {
            first: 0,
            last: -1
        };
    }
    var offset = scrollMetrics.offset, velocity = scrollMetrics.velocity, visibleLength = scrollMetrics.visibleLength, _scrollMetrics_zoomScale = scrollMetrics.zoomScale, zoomScale = _scrollMetrics_zoomScale === void 0 ? 1 : _scrollMetrics_zoomScale;
    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;
    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));
    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = listMetrics.getCellMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
        // Entire list is before our overscan window
        return {
            first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
            last: itemCount - 1
        };
    }
    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapOffsets = _sliced_to_array._(elementsThatOverlapOffsets([
        overscanBegin,
        visibleBegin,
        visibleEnd,
        overscanEnd
    ], props, listMetrics, zoomScale), 4), overscanFirst = _elementsThatOverlapOffsets[0], first = _elementsThatOverlapOffsets[1], last = _elementsThatOverlapOffsets[2], overscanLast = _elementsThatOverlapOffsets[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
        first,
        last
    };
    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while(true){
        if (first <= overscanFirst && last >= overscanLast) {
            break;
        }
        var maxNewCells = newCellCount >= maxToRenderPerBatch;
        var firstWillAddMore = void 0;
        var lastWillAddMore = void 0;
        if (_ReactNativeFeatureFlags.fixVirtualizeListCollapseWindowSize()) {
            firstWillAddMore = first <= prev.first;
            lastWillAddMore = last >= prev.last;
        } else {
            firstWillAddMore = first <= prev.first || first > prev.last;
            lastWillAddMore = last >= prev.last || last < prev.first;
        }
        var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
        var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
        if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
            break;
        }
        if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
            if (firstWillAddMore) {
                newCellCount++;
            }
            first--;
        }
        if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
            if (lastWillAddMore) {
                newCellCount++;
            }
            last++;
        }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
        throw new Error('Bad window calculation ' + JSON.stringify({
            first,
            last,
            itemCount,
            overscanFirst,
            overscanLast,
            visible
        }));
    }
    return {
        first,
        last
    };
}
function keyExtractor(item, index) {
    if (typeof item === 'object' && (item === null || item === void 0 ? void 0 : item.key) != null) {
        return item.key;
    }
    if (typeof item === 'object' && (item === null || item === void 0 ? void 0 : item.id) != null) {
        return item.id;
    }
    return String(index);
}


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js": 
/*!*********************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js ***!
  \*********************************************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ "./node_modules/@swc/helpers/cjs/_object_without_properties.cjs");
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
var _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _Batchinator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../Interaction/Batchinator */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Interaction/Batchinator.js"));
var _clamp = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../Utilities/clamp */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/clamp.js"));
var _infoLog = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../Utilities/infoLog */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/infoLog.js"));
var _CellRenderMask = __webpack_require__(/*! ./CellRenderMask */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js");
var _ChildListCollection = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ChildListCollection */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ChildListCollection.js"));
var _FillRateHelper = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./FillRateHelper */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js"));
var _ListMetricsAggregator = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ListMetricsAggregator */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"));
var _StateSafePureComponent = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./StateSafePureComponent */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/StateSafePureComponent.js"));
var _ViewabilityHelper = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ViewabilityHelper */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js"));
var _VirtualizedListCellRenderer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./VirtualizedListCellRenderer */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js"));
var _VirtualizedListContext = __webpack_require__(/*! ./VirtualizedListContext.js */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js");
var _VirtualizedListProps = __webpack_require__(/*! ./VirtualizedListProps */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js");
var _VirtualizeUtils = __webpack_require__(/*! ./VirtualizeUtils */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var _nullthrows = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! nullthrows */ "./node_modules/nullthrows/nullthrows.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
var _reactnative = __webpack_require__(/*! react-native */ "webpack/sharing/consume/default/react-native/react-native?36cc");
var ON_EDGE_REACHED_EPSILON = 0.001;
var _usedIndexForKey = false;
var _keylessItemComponentName = '';
function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
}
/**
 * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
 * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
 * documented. In general, this should only really be used if you need more flexibility than
 * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
 *
 * Virtualization massively improves memory consumption and performance of large lists by
 * maintaining a finite render window of active items and replacing all items outside of the render
 * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
 * are rendered incrementally with low-pri (after any running interactions) if they are far from the
 * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
 *
 * Some caveats:
 *
 * - Internal state is not preserved when content scrolls out of the render window. Make sure all
 *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
 * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
 *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
 *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
 *   changes. This includes the `data` prop and parent component state.
 * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
 *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
 *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
 *   and we are working on improving it behind the scenes.
 * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
 *   Alternatively, you can provide a custom `keyExtractor` prop.
 * - As an effort to remove defaultProps, use helper functions when referencing certain props
 *
 */ var VirtualizedList = /*#__PURE__*/ function(StateSafePureComponent) {
    "use strict";
    _inherits._(VirtualizedList, StateSafePureComponent);
    function VirtualizedList(props) {
        _class_call_check._(this, VirtualizedList);
        var _this;
        var _this_props_maintainVisibleContentPosition;
        _this = _call_super._(this, VirtualizedList, [
            props
        ]), // $FlowFixMe[missing-local-annot]
        _this._getScrollMetrics = ()=>{
            return _this._scrollMetrics;
        }, // $FlowFixMe[missing-local-annot]
        _this._getOutermostParentListRef = ()=>{
            if (_this._isNestedWithSameOrientation()) {
                return _this.context.getOutermostParentListRef();
            } else {
                return _this;
            }
        }, _this._registerAsNestedChild = (childList)=>{
            _this._nestedChildLists.add(childList.ref, childList.cellKey);
            if (_this._hasInteracted) {
                childList.ref.recordInteraction();
            }
        }, _this._unregisterAsNestedChild = (childList)=>{
            _this._nestedChildLists.remove(childList.ref);
        }, _this._onUpdateSeparators = (keys, newProps)=>{
            keys.forEach((key)=>{
                var ref = key != null && _this._cellRefs[key];
                ref && ref.updateSeparatorProps(newProps);
            });
        }, _this._getSpacerKey = (isVertical)=>isVertical ? 'height' : 'width', _this._cellRefs = {}, _this._listMetrics = new _ListMetricsAggregator.default(), _this._footerLength = 0, // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex
        _this._hasTriggeredInitialScrollToIndex = false, _this._hasInteracted = false, _this._hasMore = false, _this._hasWarned = {}, _this._headerLength = 0, _this._hiPriInProgress = false // flag to prevent infinite hiPri cell limit update
        , _this._indicesToKeys = new Map(), _this._lastFocusedCellKey = null, _this._nestedChildLists = new _ChildListCollection.default(), _this._offsetFromParentVirtualizedList = 0, _this._pendingViewabilityUpdate = false, _this._prevParentOffset = 0, _this._scrollMetrics = {
            dOffset: 0,
            dt: 10,
            offset: 0,
            timestamp: 0,
            velocity: 0,
            visibleLength: 0,
            zoomScale: 1
        }, _this._scrollRef = null, _this._sentStartForContentLength = 0, _this._sentEndForContentLength = 0, _this._viewabilityTuples = [], /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
   * LTI update could not be added via codemod */ _this._captureScrollRef = (ref)=>{
            _this._scrollRef = ref;
        }, /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
   * LTI update could not be added via codemod */ _this._defaultRenderScrollComponent = (props)=>{
            var onRefresh = props.onRefresh;
            if (_this._isNestedWithSameOrientation()) {
                // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.
                // This could lead to internal inconsistencies within VirtualizedList.
                var onContentSizeChange = props.onContentSizeChange, otherProps = _object_without_properties._(props, [
                    "onContentSizeChange"
                ]);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, _object_spread._({}, otherProps));
            } else if (onRefresh) {
                (0, _invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing ?? 'undefined') + '`');
                return(// $FlowFixMe[prop-missing] Invalid prop usage
                // $FlowFixMe[incompatible-use]
                /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.ScrollView, _object_spread_props._(_object_spread._({}, props), {
                    refreshControl: props.refreshControl == null ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.RefreshControl, {
                        // $FlowFixMe[incompatible-type]
                        refreshing: props.refreshing,
                        onRefresh: onRefresh,
                        progressViewOffset: props.progressViewOffset
                    }) : props.refreshControl
                })));
            } else {
                // $FlowFixMe[prop-missing] Invalid prop usage
                // $FlowFixMe[incompatible-use]
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.ScrollView, _object_spread._({}, props));
            }
        }, _this._onCellLayout = (e, cellKey, cellIndex)=>{
            var layoutHasChanged = _this._listMetrics.notifyCellLayout({
                cellIndex,
                cellKey,
                layout: e.nativeEvent.layout,
                orientation: _this._orientation()
            });
            if (layoutHasChanged) {
                _this._scheduleCellsToRenderUpdate();
            }
            _this._triggerRemeasureForChildListsInCell(cellKey);
            _this._computeBlankness();
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
        }, _this._onCellFocusCapture = (cellKey)=>{
            _this._lastFocusedCellKey = cellKey;
            _this._updateCellsToRender();
        }, _this._onCellUnmount = (cellKey)=>{
            delete _this._cellRefs[cellKey];
            _this._listMetrics.notifyCellUnmounted(cellKey);
        }, _this._onLayout = (e)=>{
            if (_this._isNestedWithSameOrientation()) {
                // Need to adjust our scroll metrics to be relative to our containing
                // VirtualizedList before we can make claims about list item viewability
                _this.measureLayoutRelativeToContainingList();
            } else {
                _this._scrollMetrics.visibleLength = _this._selectLength(e.nativeEvent.layout);
            }
            _this.props.onLayout && _this.props.onLayout(e);
            _this._scheduleCellsToRenderUpdate();
            _this._maybeCallOnEdgeReached();
        }, _this._onLayoutEmpty = (e)=>{
            _this.props.onLayout && _this.props.onLayout(e);
        }, _this._onLayoutFooter = (e)=>{
            _this._triggerRemeasureForChildListsInCell(_this._getFooterCellKey());
            _this._footerLength = _this._selectLength(e.nativeEvent.layout);
        }, _this._onLayoutHeader = (e)=>{
            _this._headerLength = _this._selectLength(e.nativeEvent.layout);
        }, _this._onContentSizeChange = (width, height)=>{
            _this._listMetrics.notifyListContentLayout({
                layout: {
                    width,
                    height
                },
                orientation: _this._orientation()
            });
            _this._maybeScrollToInitialScrollIndex(width, height);
            if (_this.props.onContentSizeChange) {
                _this.props.onContentSizeChange(width, height);
            }
            _this._scheduleCellsToRenderUpdate();
            _this._maybeCallOnEdgeReached();
        }, /* Translates metrics from a scroll event in a parent VirtualizedList into
   * coordinates relative to the child list.
   */ _this._convertParentScrollMetrics = (metrics)=>{
            // Offset of the top of the nested list relative to the top of its parent's viewport
            var offset = metrics.offset - _this._offsetFromParentVirtualizedList;
            // Child's visible length is the same as its parent's
            var visibleLength = metrics.visibleLength;
            var dOffset = offset - _this._scrollMetrics.offset;
            var contentLength = _this._listMetrics.getContentLength();
            return {
                visibleLength,
                contentLength,
                offset,
                dOffset
            };
        }, _this._onScroll = (e)=>{
            _this._nestedChildLists.forEach((childList)=>{
                childList._onScroll(e);
            });
            if (_this.props.onScroll) {
                _this.props.onScroll(e);
            }
            var timestamp = e.timeStamp;
            var visibleLength = _this._selectLength(e.nativeEvent.layoutMeasurement);
            var contentLength = _this._selectLength(e.nativeEvent.contentSize);
            var offset = _this._offsetFromScrollEvent(e);
            var dOffset = offset - _this._scrollMetrics.offset;
            if (_this._isNestedWithSameOrientation()) {
                if (_this._listMetrics.getContentLength() === 0) {
                    // Ignore scroll events until onLayout has been called and we
                    // know our offset from our offset from our parent
                    return;
                }
                var ref;
                ref = _this._convertParentScrollMetrics({
                    visibleLength,
                    offset
                }), visibleLength = ref.visibleLength, contentLength = ref.contentLength, offset = ref.offset, dOffset = ref.dOffset, ref;
            }
            var dt = _this._scrollMetrics.timestamp ? Math.max(1, timestamp - _this._scrollMetrics.timestamp) : 1;
            var velocity = dOffset / dt;
            if (dt > 500 && _this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !_this._hasWarned.perf) {
                (0, _infoLog.default)('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {
                    dt,
                    prevDt: _this._scrollMetrics.dt,
                    contentLength
                });
                _this._hasWarned.perf = true;
            }
            // For invalid negative values (w/ RTL), set this to 1.
            var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
            _this._scrollMetrics = {
                dt,
                dOffset,
                offset,
                timestamp,
                velocity,
                visibleLength,
                zoomScale
            };
            if (_this.state.pendingScrollUpdateCount > 0) {
                _this.setState((state)=>({
                        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1
                    }));
            }
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
            if (!_this.props) {
                return;
            }
            _this._maybeCallOnEdgeReached();
            if (velocity !== 0) {
                _this._fillRateHelper.activate();
            }
            _this._computeBlankness();
            _this._scheduleCellsToRenderUpdate();
        }, _this._onScrollBeginDrag = (e)=>{
            _this._nestedChildLists.forEach((childList)=>{
                childList._onScrollBeginDrag(e);
            });
            _this._viewabilityTuples.forEach((tuple)=>{
                tuple.viewabilityHelper.recordInteraction();
            });
            _this._hasInteracted = true;
            _this.props.onScrollBeginDrag && _this.props.onScrollBeginDrag(e);
        }, _this._onScrollEndDrag = (e)=>{
            _this._nestedChildLists.forEach((childList)=>{
                childList._onScrollEndDrag(e);
            });
            var velocity = e.nativeEvent.velocity;
            if (velocity) {
                _this._scrollMetrics.velocity = _this._selectOffset(velocity);
            }
            _this._computeBlankness();
            _this.props.onScrollEndDrag && _this.props.onScrollEndDrag(e);
        }, _this._onMomentumScrollBegin = (e)=>{
            _this._nestedChildLists.forEach((childList)=>{
                childList._onMomentumScrollBegin(e);
            });
            _this.props.onMomentumScrollBegin && _this.props.onMomentumScrollBegin(e);
        }, _this._onMomentumScrollEnd = (e)=>{
            _this._nestedChildLists.forEach((childList)=>{
                childList._onMomentumScrollEnd(e);
            });
            _this._scrollMetrics.velocity = 0;
            _this._computeBlankness();
            _this.props.onMomentumScrollEnd && _this.props.onMomentumScrollEnd(e);
        }, _this._updateCellsToRender = ()=>{
            _this._updateViewableItems(_this.props, _this.state.cellsAroundViewport);
            _this.setState((state, props)=>{
                var cellsAroundViewport = _this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);
                var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, _this._getNonViewportRenderRegions(props));
                if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
                    return null;
                }
                return {
                    cellsAroundViewport,
                    renderMask
                };
            });
        }, _this._createViewToken = (index, isViewable, props)=>{
            var data = props.data, getItem = props.getItem;
            var item = getItem(data, index);
            return {
                index,
                item,
                key: VirtualizedList._keyExtractor(item, index, props),
                isViewable
            };
        }, _this._getNonViewportRenderRegions = (props)=>{
            // Keep a viewport's worth of content around the last focused cell to allow
            // random navigation around it without any blanking. E.g. tabbing from one
            // focused item out of viewport to another.
            if (!(_this._lastFocusedCellKey && _this._cellRefs[_this._lastFocusedCellKey])) {
                return [];
            }
            var lastFocusedCellRenderer = _this._cellRefs[_this._lastFocusedCellKey];
            var focusedCellIndex = lastFocusedCellRenderer.props.index;
            var itemCount = props.getItemCount(props.data);
            // The last cell we rendered may be at a new index. Bail if we don't know
            // where it is.
            if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== _this._lastFocusedCellKey) {
                return [];
            }
            var first = focusedCellIndex;
            var heightOfCellsBeforeFocused = 0;
            for(var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < _this._scrollMetrics.visibleLength; i--){
                first--;
                heightOfCellsBeforeFocused += _this._listMetrics.getCellMetricsApprox(i, props).length;
            }
            var last = focusedCellIndex;
            var heightOfCellsAfterFocused = 0;
            for(var i1 = last + 1; i1 < itemCount && heightOfCellsAfterFocused < _this._scrollMetrics.visibleLength; i1++){
                last++;
                heightOfCellsAfterFocused += _this._listMetrics.getCellMetricsApprox(i1, props).length;
            }
            return [
                {
                    first,
                    last
                }
            ];
        };
        _this._checkProps(props);
        _this._fillRateHelper = new _FillRateHelper.default(_this._listMetrics);
        _this._updateCellsToRenderBatcher = new _Batchinator.default(_this._updateCellsToRender, _this.props.updateCellsBatchingPeriod ?? 50);
        if (_this.props.viewabilityConfigCallbackPairs) {
            _this._viewabilityTuples = _this.props.viewabilityConfigCallbackPairs.map((pair)=>({
                    viewabilityHelper: new _ViewabilityHelper.default(pair.viewabilityConfig),
                    onViewableItemsChanged: pair.onViewableItemsChanged
                }));
        } else {
            var _this_props = _this.props, onViewableItemsChanged = _this_props.onViewableItemsChanged, viewabilityConfig = _this_props.viewabilityConfig;
            if (onViewableItemsChanged) {
                _this._viewabilityTuples.push({
                    viewabilityHelper: new _ViewabilityHelper.default(viewabilityConfig),
                    onViewableItemsChanged: onViewableItemsChanged
                });
            }
        }
        var initialRenderRegion = VirtualizedList._initialRenderRegion(props);
        var minIndexForVisible = ((_this_props_maintainVisibleContentPosition = _this.props.maintainVisibleContentPosition) === null || _this_props_maintainVisibleContentPosition === void 0 ? void 0 : _this_props_maintainVisibleContentPosition.minIndexForVisible) ?? 0;
        _this.state = {
            cellsAroundViewport: initialRenderRegion,
            renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),
            firstVisibleItemKey: _this.props.getItemCount(_this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(_this.props, minIndexForVisible) : null,
            // When we have a non-zero initialScrollIndex, we will receive a
            // scroll event later so this will prevent the window from updating
            // until we get a valid offset.
            pendingScrollUpdateCount: _this.props.initialScrollIndex != null && _this.props.initialScrollIndex > 0 ? 1 : 0
        };
        return _this;
    }
    _create_class._(VirtualizedList, [
        {
            // scrollToEnd may be janky without getItemLayout prop
            key: "scrollToEnd",
            value: function scrollToEnd(params) {
                var animated = params ? params.animated : true;
                var veryLast = this.props.getItemCount(this.props.data) - 1;
                if (veryLast < 0) {
                    return;
                }
                var frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);
                var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
                // TODO: consider using `ref.scrollToEnd` directly
                this.scrollToOffset({
                    animated,
                    offset
                });
            }
        },
        {
            // scrollToIndex may be janky without getItemLayout prop
            key: "scrollToIndex",
            value: function scrollToIndex(params) {
                var _this_props = this.props, data = _this_props.data, getItemCount = _this_props.getItemCount, getItemLayout = _this_props.getItemLayout, onScrollToIndexFailed = _this_props.onScrollToIndexFailed;
                var animated = params.animated, index = params.index, viewOffset = params.viewOffset, viewPosition = params.viewPosition;
                (0, _invariant.default)(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`);
                (0, _invariant.default)(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`);
                (0, _invariant.default)(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`);
                if (!getItemLayout && index > this._listMetrics.getHighestMeasuredCellIndex()) {
                    (0, _invariant.default)(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');
                    onScrollToIndexFailed({
                        averageItemLength: this._listMetrics.getAverageCellLength(),
                        highestMeasuredFrameIndex: this._listMetrics.getHighestMeasuredCellIndex(),
                        index
                    });
                    return;
                }
                var frame = this._listMetrics.getCellMetricsApprox(Math.floor(index), this.props);
                var offset = Math.max(0, this._listMetrics.getCellOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
                this.scrollToOffset({
                    offset,
                    animated
                });
            }
        },
        {
            // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
            // use scrollToIndex instead if possible.
            key: "scrollToItem",
            value: function scrollToItem(params) {
                var item = params.item;
                var _this_props = this.props, data = _this_props.data, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount;
                var itemCount = getItemCount(data);
                for(var index = 0; index < itemCount; index++){
                    if (getItem(data, index) === item) {
                        this.scrollToIndex(_object_spread_props._(_object_spread._({}, params), {
                            index
                        }));
                        break;
                    }
                }
            }
        },
        {
            /**
   * Scroll to a specific content pixel offset in the list.
   *
   * Param `offset` expects the offset to scroll to.
   * In case of `horizontal` is true, the offset is the x-value,
   * in any other case the offset is the y-value.
   *
   * Param `animated` (`true` by default) defines whether the list
   * should do an animation while scrolling.
   */ key: "scrollToOffset",
            value: function scrollToOffset(params) {
                var animated = params.animated, offset = params.offset;
                var scrollRef = this._scrollRef;
                if (scrollRef == null) {
                    return;
                }
                if (scrollRef.scrollTo == null) {
                    console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');
                    return;
                }
                var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
                if (horizontal && rtl && !this._listMetrics.hasContentLength()) {
                    console.warn('scrollToOffset may not be called in RTL before content is laid out');
                    return;
                }
                scrollRef.scrollTo(_object_spread._({
                    animated
                }, this._scrollToParamsFromOffset(offset)));
            }
        },
        {
            key: "_scrollToParamsFromOffset",
            value: function _scrollToParamsFromOffset(offset) {
                var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
                if (horizontal && rtl) {
                    // Add the visible length of the scrollview so that the offset is right-aligned
                    var cartOffset = this._listMetrics.cartesianOffset(offset + this._scrollMetrics.visibleLength);
                    return horizontal ? {
                        x: cartOffset
                    } : {
                        y: cartOffset
                    };
                } else {
                    return horizontal ? {
                        x: offset
                    } : {
                        y: offset
                    };
                }
            }
        },
        {
            key: "recordInteraction",
            value: function recordInteraction() {
                this._nestedChildLists.forEach((childList)=>{
                    childList.recordInteraction();
                });
                this._viewabilityTuples.forEach((t)=>{
                    t.viewabilityHelper.recordInteraction();
                });
                this._updateViewableItems(this.props, this.state.cellsAroundViewport);
            }
        },
        {
            key: "flashScrollIndicators",
            value: function flashScrollIndicators() {
                if (this._scrollRef == null) {
                    return;
                }
                this._scrollRef.flashScrollIndicators();
            }
        },
        {
            /**
   * Provides a handle to the underlying scroll responder.
   * Note that `this._scrollRef` might not be a `ScrollView`, so we
   * need to check that it responds to `getScrollResponder` before calling it.
   */ key: "getScrollResponder",
            value: function getScrollResponder() {
                if (this._scrollRef && this._scrollRef.getScrollResponder) {
                    return this._scrollRef.getScrollResponder();
                }
            }
        },
        {
            key: "getScrollableNode",
            value: function getScrollableNode() {
                if (this._scrollRef && this._scrollRef.getScrollableNode) {
                    return this._scrollRef.getScrollableNode();
                } else {
                    return (0, _reactnative.findNodeHandle)(this._scrollRef);
                }
            }
        },
        {
            key: "getScrollRef",
            value: function getScrollRef() {
                if (this._scrollRef && this._scrollRef.getScrollRef) {
                    return this._scrollRef.getScrollRef();
                } else {
                    return this._scrollRef;
                }
            }
        },
        {
            key: "setNativeProps",
            value: function setNativeProps(props) {
                if (this._scrollRef) {
                    this._scrollRef.setNativeProps(props);
                }
            }
        },
        {
            key: "_getCellKey",
            value: function _getCellKey() {
                var _this_context;
                return ((_this_context = this.context) === null || _this_context === void 0 ? void 0 : _this_context.cellKey) || 'rootList';
            }
        },
        {
            key: "hasMore",
            value: function hasMore() {
                return this._hasMore;
            }
        },
        {
            key: "_checkProps",
            value: function _checkProps(props) {
                var onScroll = props.onScroll, windowSize = props.windowSize, getItemCount = props.getItemCount, data = props.data, initialScrollIndex = props.initialScrollIndex;
                (0, _invariant.default)(// $FlowFixMe[prop-missing]
                !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
                (0, _invariant.default)((0, _VirtualizedListProps.windowSizeOrDefault)(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
                (0, _invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
                var itemCount = getItemCount(data);
                if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
                    console.warn(`initialScrollIndex "${initialScrollIndex}" is not valid (list has ${itemCount} items)`);
                    this._hasWarned.initialScrollIndex = true;
                }
                if ( true && !this._hasWarned.flexWrap) {
                    // $FlowFixMe[underconstrained-implicit-instantiation]
                    var flatStyles = _reactnative.StyleSheet.flatten(this.props.contentContainerStyle);
                    if (flatStyles != null && flatStyles.flexWrap === 'wrap') {
                        console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');
                        this._hasWarned.flexWrap = true;
                    }
                }
            }
        },
        {
            key: "_adjustCellsAroundViewport",
            value: function _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {
                var data = props.data, getItemCount = props.getItemCount;
                var onEndReachedThreshold = (0, _VirtualizedListProps.onEndReachedThresholdOrDefault)(props.onEndReachedThreshold);
                var _this__scrollMetrics = this._scrollMetrics, offset = _this__scrollMetrics.offset, visibleLength = _this__scrollMetrics.visibleLength;
                var contentLength = this._listMetrics.getContentLength();
                var distanceFromEnd = contentLength - visibleLength - offset;
                // Wait until the scroll view metrics have been set up. And until then,
                // we will trust the initialNumToRender suggestion
                if (visibleLength <= 0 || contentLength <= 0) {
                    return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
                }
                var newCellsAroundViewport;
                if (props.disableVirtualization) {
                    var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch) : 0;
                    newCellsAroundViewport = {
                        first: 0,
                        last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
                    };
                } else {
                    // If we have a pending scroll update, we should not adjust the render window as it
                    // might override the correct window.
                    if (pendingScrollUpdateCount > 0) {
                        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
                    }
                    newCellsAroundViewport = (0, _VirtualizeUtils.computeWindowedRenderLimits)(props, (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch), (0, _VirtualizedListProps.windowSizeOrDefault)(props.windowSize), cellsAroundViewport, this._listMetrics, this._scrollMetrics);
                    (0, _invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
                }
                if (this._nestedChildLists.size() > 0) {
                    // If some cell in the new state has a child list in it, we should only render
                    // up through that item, so that we give that list a chance to render.
                    // Otherwise there's churn from multiple child lists mounting and un-mounting
                    // their items.
                    // Will this prevent rendering if the nested list doesn't realize the end?
                    var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
                    newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;
                }
                return newCellsAroundViewport;
            }
        },
        {
            key: "_findFirstChildWithMore",
            value: function _findFirstChildWithMore(first, last) {
                for(var ii = first; ii <= last; ii++){
                    var cellKeyForIndex = this._indicesToKeys.get(ii);
                    if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, (childList)=>childList.hasMore())) {
                        return ii;
                    }
                }
                return null;
            }
        },
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                if (this._isNestedWithSameOrientation()) {
                    this.context.registerAsNestedChild({
                        ref: this,
                        cellKey: this.context.cellKey
                    });
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this._isNestedWithSameOrientation()) {
                    this.context.unregisterAsNestedChild({
                        ref: this
                    });
                }
                this._updateCellsToRenderBatcher.dispose();
                this._viewabilityTuples.forEach((tuple)=>{
                    tuple.viewabilityHelper.dispose();
                });
                this._fillRateHelper.deactivateAndFlush();
            }
        },
        {
            key: "_pushCells",
            value: function _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
                var _this, _loop = function(ii) {
                    var item = getItem(data, ii);
                    var key = VirtualizedList._keyExtractor(item, ii, _this.props);
                    _this._indicesToKeys.set(ii, key);
                    if (stickyIndicesFromProps.has(ii + stickyOffset)) {
                        stickyHeaderIndices.push(cells.length);
                    }
                    var shouldListenForLayout = getItemLayout == null || debug || _this._fillRateHelper.enabled();
                    cells.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListCellRenderer.default, _object_spread._({
                        CellRendererComponent: CellRendererComponent,
                        ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
                        ListItemComponent: ListItemComponent,
                        cellKey: key,
                        horizontal: horizontal,
                        index: ii,
                        inversionStyle: inversionStyle,
                        item: item,
                        prevCellKey: prevCellKey,
                        onUpdateSeparators: _this._onUpdateSeparators,
                        onCellFocusCapture: _this._onCellFocusCapture,
                        onUnmount: _this._onCellUnmount,
                        ref: (ref)=>{
                            _this._cellRefs[key] = ref;
                        },
                        renderItem: renderItem
                    }, shouldListenForLayout && {
                        onCellLayout: _this._onCellLayout
                    }), key));
                    prevCellKey = key;
                };
                var _this_props = this.props, CellRendererComponent = _this_props.CellRendererComponent, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, ListHeaderComponent = _this_props.ListHeaderComponent, ListItemComponent = _this_props.ListItemComponent, data = _this_props.data, debug = _this_props.debug, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount, getItemLayout = _this_props.getItemLayout, horizontal = _this_props.horizontal, renderItem = _this_props.renderItem;
                var stickyOffset = ListHeaderComponent ? 1 : 0;
                var end = getItemCount(data) - 1;
                var prevCellKey;
                last = Math.min(end, last);
                for(var ii = first; ii <= last; ii++)_this = this, _loop(ii);
            }
        },
        {
            key: "_isNestedWithSameOrientation",
            value: function _isNestedWithSameOrientation() {
                var nestedContext = this.context;
                return !!(nestedContext && !!nestedContext.horizontal === (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal));
            }
        },
        {
            key: "render",
            value: function render() {
                this._checkProps(this.props);
                var _this_props = this.props, ListEmptyComponent = _this_props.ListEmptyComponent, ListFooterComponent = _this_props.ListFooterComponent, ListHeaderComponent = _this_props.ListHeaderComponent;
                var _this_props1 = this.props, data = _this_props1.data, horizontal = _this_props1.horizontal;
                var inversionStyle = this.props.inverted ? (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
                var cells = [];
                var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
                var stickyHeaderIndices = [];
                // 1. Add cell for ListHeaderComponent
                if (ListHeaderComponent) {
                    if (stickyIndicesFromProps.has(0)) {
                        stickyHeaderIndices.push(0);
                    }
                    var element = /*#__PURE__*/ _react.isValidElement(ListHeaderComponent) ? ListHeaderComponent : // $FlowFixMe[not-a-component]
                    // $FlowFixMe[incompatible-type-arg]
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ListHeaderComponent, {});
                    cells.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                        cellKey: this._getCellKey() + '-header',
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                            // We expect that header component will be a single native view so make it
                            // not collapsable to avoid this view being flattened and make this assumption
                            // no longer true.
                            collapsable: false,
                            onLayout: this._onLayoutHeader,
                            style: _reactnative.StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),
                            children: // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
                            element
                        })
                    }, "$header"));
                }
                // 2a. Add a cell for ListEmptyComponent if applicable
                var itemCount = this.props.getItemCount(data);
                if (itemCount === 0 && ListEmptyComponent) {
                    var element1 = /*#__PURE__*/ _react.isValidElement(ListEmptyComponent) ? ListEmptyComponent : // $FlowFixMe[not-a-component]
                    // $FlowFixMe[incompatible-type-arg]
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ListEmptyComponent, {});
                    cells.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                        cellKey: this._getCellKey() + '-empty',
                        children: /*#__PURE__*/ _react.cloneElement(element1, {
                            onLayout: (event)=>{
                                this._onLayoutEmpty(event);
                                // $FlowFixMe[prop-missing] React.Element internal inspection
                                if (element1.props.onLayout) {
                                    element1.props.onLayout(event);
                                }
                            },
                            // $FlowFixMe[prop-missing] React.Element internal inspection
                            style: _reactnative.StyleSheet.compose(inversionStyle, element1.props.style)
                        })
                    }, "$empty"));
                }
                // 2b. Add cells and spacers for each item
                if (itemCount > 0) {
                    _usedIndexForKey = false;
                    _keylessItemComponentName = '';
                    var spacerKey = this._getSpacerKey(!horizontal);
                    var renderRegions = this.state.renderMask.enumerateRegions();
                    var lastRegion = renderRegions[renderRegions.length - 1];
                    var lastSpacer = (lastRegion === null || lastRegion === void 0 ? void 0 : lastRegion.isSpacer) ? lastRegion : null;
                    for (var section of renderRegions){
                        if (section.isSpacer) {
                            // Legacy behavior is to avoid spacers when virtualization is
                            // disabled (including head spacers on initial render).
                            if (this.props.disableVirtualization) {
                                continue;
                            }
                            // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
                            // prevent the user for hyperscrolling into un-measured area because otherwise content will
                            // likely jump around as it renders in above the viewport.
                            var isLastSpacer = section === lastSpacer;
                            var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
                            var last = constrainToMeasured ? (0, _clamp.default)(section.first - 1, section.last, this._listMetrics.getHighestMeasuredCellIndex()) : section.last;
                            var firstMetrics = this._listMetrics.getCellMetricsApprox(section.first, this.props);
                            var lastMetrics = this._listMetrics.getCellMetricsApprox(last, this.props);
                            var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
                            cells.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                                // $FlowFixMe[incompatible-type]
                                style: {
                                    [spacerKey]: spacerSize
                                }
                            }, `$spacer-${section.first}`));
                        } else {
                            this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
                        }
                    }
                    if (!this._hasWarned.keys && _usedIndexForKey) {
                        console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);
                        this._hasWarned.keys = true;
                    }
                }
                // 3. Add cell for ListFooterComponent
                if (ListFooterComponent) {
                    var element2 = /*#__PURE__*/ _react.isValidElement(ListFooterComponent) ? ListFooterComponent : // $FlowFixMe[not-a-component]
                    // $FlowFixMe[incompatible-type-arg]
                    /*#__PURE__*/ (0, _jsxruntime.jsx)(ListFooterComponent, {});
                    cells.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                        cellKey: this._getFooterCellKey(),
                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                            onLayout: this._onLayoutFooter,
                            style: _reactnative.StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),
                            children: // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
                            element2
                        })
                    }, "$footer"));
                }
                // 4. Render the ScrollView
                var scrollProps = _object_spread_props._(_object_spread._({}, this.props), {
                    onContentSizeChange: this._onContentSizeChange,
                    onLayout: this._onLayout,
                    onScroll: this._onScroll,
                    onScrollBeginDrag: this._onScrollBeginDrag,
                    onScrollEndDrag: this._onScrollEndDrag,
                    onMomentumScrollBegin: this._onMomentumScrollBegin,
                    onMomentumScrollEnd: this._onMomentumScrollEnd,
                    // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a
                    // single notification while scrolling. This will otherwise no-op.
                    scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,
                    invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
                    stickyHeaderIndices,
                    style: inversionStyle ? [
                        inversionStyle,
                        this.props.style
                    ] : this.props.style,
                    isInvertedVirtualizedList: this.props.inverted,
                    maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? _object_spread_props._(_object_spread._({}, this.props.maintainVisibleContentPosition), {
                        // Adjust index to account for ListHeaderComponent.
                        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)
                    }) : undefined
                });
                this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
                var innerRet = /*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListContext.VirtualizedListContextProvider, {
                    value: {
                        cellKey: null,
                        getScrollMetrics: this._getScrollMetrics,
                        horizontal: (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal),
                        getOutermostParentListRef: this._getOutermostParentListRef,
                        registerAsNestedChild: this._registerAsNestedChild,
                        unregisterAsNestedChild: this._unregisterAsNestedChild
                    },
                    children: /*#__PURE__*/ _react.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
                        ref: this._captureScrollRef
                    }, cells)
                });
                var ret = innerRet;
                if (true) {
                    ret = /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.ScrollView.Context.Consumer, {
                        children: (scrollContext)=>{
                            if (scrollContext != null && !scrollContext.horizontal === !(0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal) && !this._hasWarned.nesting && this.context == null && this.props.scrollEnabled !== false) {
                                console.error('VirtualizedLists should never be nested inside plain ScrollViews with the same ' + 'orientation because it can break windowing and other functionality - use another ' + 'VirtualizedList-backed container instead.');
                                this._hasWarned.nesting = true;
                            }
                            return innerRet;
                        }
                    });
                }
                if (this.props.debug) {
                    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_reactnative.View, {
                        style: styles.debug,
                        children: [
                            ret,
                            this._renderDebugOverlay()
                        ]
                    });
                } else {
                    return ret;
                }
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps) {
                var _this_props = this.props, data = _this_props.data, extraData = _this_props.extraData, getItemLayout = _this_props.getItemLayout;
                if (data !== prevProps.data || extraData !== prevProps.extraData) {
                    // clear the viewableIndices cache to also trigger
                    // the onViewableItemsChanged callback with the new data
                    this._viewabilityTuples.forEach((tuple)=>{
                        tuple.viewabilityHelper.resetViewableIndices();
                    });
                }
                // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
                // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
                // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
                // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
                // `_scheduleCellsToRenderUpdate` will check this condition and not perform
                // another hiPri update.
                var hiPriInProgress = this._hiPriInProgress;
                this._scheduleCellsToRenderUpdate();
                // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
                // is triggered with `this._hiPriInProgress = true`
                if (hiPriInProgress) {
                    this._hiPriInProgress = false;
                }
                // We only call `onEndReached` after we render the last cell, but when
                // getItemLayout is present, we can scroll past the last rendered cell, and
                // never trigger a new layout or bounds change, so we need to check again
                // after rendering more cells.
                if (getItemLayout != null) {
                    this._maybeCallOnEdgeReached();
                }
            }
        },
        {
            key: "_computeBlankness",
            value: function _computeBlankness() {
                this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
            }
        },
        {
            key: "_triggerRemeasureForChildListsInCell",
            value: function _triggerRemeasureForChildListsInCell(cellKey) {
                this._nestedChildLists.forEachInCell(cellKey, (childList)=>{
                    childList.measureLayoutRelativeToContainingList();
                });
            }
        },
        {
            key: "measureLayoutRelativeToContainingList",
            value: function measureLayoutRelativeToContainingList() {
                // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
                // node on an unmounted component" during scrolling
                try {
                    if (!this._scrollRef) {
                        return;
                    }
                    // We are assuming that getOutermostParentListRef().getScrollRef()
                    // is a non-null reference to a ScrollView
                    this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height)=>{
                        this._offsetFromParentVirtualizedList = this._selectOffset({
                            x,
                            y
                        });
                        this._listMetrics.notifyListContentLayout({
                            layout: {
                                width,
                                height
                            },
                            orientation: this._orientation()
                        });
                        var scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());
                        var metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;
                        if (metricsChanged) {
                            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
                            this._scrollMetrics.offset = scrollMetrics.offset;
                            // If metrics of the scrollView changed, then we triggered remeasure for child list
                            // to ensure VirtualizedList has the right information.
                            this._nestedChildLists.forEach((childList)=>{
                                childList.measureLayoutRelativeToContainingList();
                            });
                        }
                    }, (error)=>{
                        console.warn("VirtualizedList: Encountered an error while measuring a list's" + ' offset from its containing VirtualizedList.');
                    });
                } catch (error) {
                    console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
                }
            }
        },
        {
            key: "_getFooterCellKey",
            value: function _getFooterCellKey() {
                return this._getCellKey() + '-footer';
            }
        },
        {
            // $FlowFixMe[missing-local-annot]
            key: "_renderDebugOverlay",
            value: function _renderDebugOverlay() {
                var normalize = this._scrollMetrics.visibleLength / (this._listMetrics.getContentLength() || 1);
                var framesInLayout = [];
                var itemCount = this.props.getItemCount(this.props.data);
                for(var ii = 0; ii < itemCount; ii++){
                    var frame = this._listMetrics.getCellMetricsApprox(ii, this.props);
                    if (frame.isMounted) {
                        framesInLayout.push(frame);
                    }
                }
                var windowTop = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
                var frameLast = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.last, this.props);
                var windowLen = frameLast.offset + frameLast.length - windowTop;
                var visTop = this._scrollMetrics.offset;
                var visLen = this._scrollMetrics.visibleLength;
                return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_reactnative.View, {
                    style: [
                        styles.debugOverlayBase,
                        styles.debugOverlay
                    ],
                    children: [
                        framesInLayout.map((f, ii)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                                style: [
                                    styles.debugOverlayBase,
                                    styles.debugOverlayFrame,
                                    {
                                        top: f.offset * normalize,
                                        height: f.length * normalize
                                    }
                                ]
                            }, 'f' + ii)),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                            style: [
                                styles.debugOverlayBase,
                                styles.debugOverlayFrameLast,
                                {
                                    top: windowTop * normalize,
                                    height: windowLen * normalize
                                }
                            ]
                        }),
                        /*#__PURE__*/ (0, _jsxruntime.jsx)(_reactnative.View, {
                            style: [
                                styles.debugOverlayBase,
                                styles.debugOverlayFrameVis,
                                {
                                    top: visTop * normalize,
                                    height: visLen * normalize
                                }
                            ]
                        })
                    ]
                });
            }
        },
        {
            key: "_selectLength",
            value: function _selectLength(metrics) {
                return !(0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal) ? metrics.height : metrics.width;
            }
        },
        {
            key: "_selectOffset",
            value: function _selectOffset(ref) {
                var x = ref.x, y = ref.y;
                return this._orientation().horizontal ? x : y;
            }
        },
        {
            key: "_orientation",
            value: function _orientation() {
                return {
                    horizontal: (0, _VirtualizedListProps.horizontalOrDefault)(this.props.horizontal),
                    rtl: _reactnative.I18nManager.isRTL
                };
            }
        },
        {
            key: "_maybeCallOnEdgeReached",
            value: function _maybeCallOnEdgeReached() {
                var _this_props = this.props, data = _this_props.data, getItemCount = _this_props.getItemCount, onStartReached = _this_props.onStartReached, onStartReachedThreshold = _this_props.onStartReachedThreshold, onEndReached = _this_props.onEndReached, onEndReachedThreshold = _this_props.onEndReachedThreshold;
                // Wait until we have real metrics
                if (!this._listMetrics.hasContentLength() || this._scrollMetrics.visibleLength === 0) {
                    return;
                }
                // If we have any pending scroll updates it means that the scroll metrics
                // are out of date and we should not call any of the edge reached callbacks.
                if (this.state.pendingScrollUpdateCount > 0) {
                    return;
                }
                var _this__scrollMetrics = this._scrollMetrics, visibleLength = _this__scrollMetrics.visibleLength, offset = _this__scrollMetrics.offset;
                var distanceFromStart = offset;
                var distanceFromEnd = this._listMetrics.getContentLength() - visibleLength - offset;
                // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
                // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
                // be at the edge of the list with a distance approximating 0 but not quite there.
                if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
                    distanceFromStart = 0;
                }
                if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
                    distanceFromEnd = 0;
                }
                // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
                // when oERT is not present (different from 2 viewports used elsewhere)
                var DEFAULT_THRESHOLD_PX = 2;
                var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
                var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
                var isWithinStartThreshold = distanceFromStart <= startThreshold;
                var isWithinEndThreshold = distanceFromEnd <= endThreshold;
                // First check if the user just scrolled within the end threshold
                // and call onEndReached only once for a given content length,
                // and only if onStartReached is not being executed
                if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._listMetrics.getContentLength() !== this._sentEndForContentLength) {
                    this._sentEndForContentLength = this._listMetrics.getContentLength();
                    onEndReached({
                        distanceFromEnd
                    });
                }
                // Next check if the user just scrolled within the start threshold
                // and call onStartReached only once for a given content length,
                // and only if onEndReached is not being executed
                if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._listMetrics.getContentLength() !== this._sentStartForContentLength) {
                    this._sentStartForContentLength = this._listMetrics.getContentLength();
                    onStartReached({
                        distanceFromStart
                    });
                }
                // If the user scrolls away from the start or end and back again,
                // cause onStartReached or onEndReached to be triggered again
                if (!isWithinStartThreshold) {
                    this._sentStartForContentLength = 0;
                }
                if (!isWithinEndThreshold) {
                    this._sentEndForContentLength = 0;
                }
            }
        },
        {
            /**
   * Scroll to a specified `initialScrollIndex` prop after the ScrollView
   * content has been laid out, if it is still valid. Only a single scroll is
   * triggered throughout the lifetime of the list.
   */ key: "_maybeScrollToInitialScrollIndex",
            value: function _maybeScrollToInitialScrollIndex(contentWidth, contentHeight) {
                if (contentWidth > 0 && contentHeight > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {
                    if (this.props.contentOffset == null) {
                        if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {
                            this.scrollToIndex({
                                animated: false,
                                index: (0, _nullthrows.default)(this.props.initialScrollIndex)
                            });
                        } else {
                            this.scrollToEnd({
                                animated: false
                            });
                        }
                    }
                    this._hasTriggeredInitialScrollToIndex = true;
                }
            }
        },
        {
            key: "unstable_onScroll",
            value: function unstable_onScroll(e) {
                this._onScroll(e);
            }
        },
        {
            key: "_offsetFromScrollEvent",
            value: function _offsetFromScrollEvent(e) {
                var _e_nativeEvent = e.nativeEvent, contentOffset = _e_nativeEvent.contentOffset, contentSize = _e_nativeEvent.contentSize, layoutMeasurement = _e_nativeEvent.layoutMeasurement;
                var _this__orientation = this._orientation(), horizontal = _this__orientation.horizontal, rtl = _this__orientation.rtl;
                if (horizontal && rtl) {
                    return this._selectLength(contentSize) - (this._selectOffset(contentOffset) + this._selectLength(layoutMeasurement));
                } else {
                    return this._selectOffset(contentOffset);
                }
            }
        },
        {
            key: "_scheduleCellsToRenderUpdate",
            value: function _scheduleCellsToRenderUpdate() {
                // Only trigger high-priority updates if we've actually rendered cells,
                // and with that size estimate, accurately compute how many cells we should render.
                // Otherwise, it would just render as many cells as it can (of zero dimension),
                // each time through attempting to render more (limited by maxToRenderPerBatch),
                // starving the renderer from actually laying out the objects and computing _averageCellLength.
                // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
                // We shouldn't do another hipri cellToRenderUpdate
                if ((this._listMetrics.getAverageCellLength() > 0 || this.props.getItemLayout != null) && this._shouldRenderWithPriority() && !this._hiPriInProgress) {
                    this._hiPriInProgress = true;
                    // Don't worry about interactions when scrolling quickly; focus on filling content as fast
                    // as possible.
                    this._updateCellsToRenderBatcher.dispose();
                    this._updateCellsToRender();
                    return;
                } else {
                    this._updateCellsToRenderBatcher.schedule();
                }
            }
        },
        {
            key: "_shouldRenderWithPriority",
            value: function _shouldRenderWithPriority() {
                var _this_state_cellsAroundViewport = this.state.cellsAroundViewport, first = _this_state_cellsAroundViewport.first, last = _this_state_cellsAroundViewport.last;
                var _this__scrollMetrics = this._scrollMetrics, offset = _this__scrollMetrics.offset, visibleLength = _this__scrollMetrics.visibleLength, velocity = _this__scrollMetrics.velocity;
                var itemCount = this.props.getItemCount(this.props.data);
                var hiPri = false;
                var onStartReachedThreshold = (0, _VirtualizedListProps.onStartReachedThresholdOrDefault)(this.props.onStartReachedThreshold);
                var onEndReachedThreshold = (0, _VirtualizedListProps.onEndReachedThresholdOrDefault)(this.props.onEndReachedThreshold);
                // Mark as high priority if we're close to the start of the first item
                // But only if there are items before the first rendered item
                if (first > 0) {
                    var distTop = offset - this._listMetrics.getCellMetricsApprox(first, this.props).offset;
                    hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
                }
                // Mark as high priority if we're close to the end of the last item
                // But only if there are items after the last rendered item
                if (!hiPri && last >= 0 && last < itemCount - 1) {
                    var distBottom = this._listMetrics.getCellMetricsApprox(last, this.props).offset - (offset + visibleLength);
                    hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
                }
                return hiPri;
            }
        },
        {
            key: "unstable_onScrollBeginDrag",
            value: function unstable_onScrollBeginDrag(e) {
                this._onScrollBeginDrag(e);
            }
        },
        {
            key: "unstable_onScrollEndDrag",
            value: function unstable_onScrollEndDrag(e) {
                this._onScrollEndDrag(e);
            }
        },
        {
            key: "unstable_onMomentumScrollBegin",
            value: function unstable_onMomentumScrollBegin(e) {
                this._onMomentumScrollBegin(e);
            }
        },
        {
            key: "unstable_onMomentumScrollEnd",
            value: function unstable_onMomentumScrollEnd(e) {
                this._onMomentumScrollEnd(e);
            }
        },
        {
            key: "__getListMetrics",
            value: function __getListMetrics() {
                return this._listMetrics;
            }
        },
        {
            key: "_updateViewableItems",
            value: function _updateViewableItems(props, cellsAroundViewport) {
                // If we have any pending scroll updates it means that the scroll metrics
                // are out of date and we should not call any of the visibility callbacks.
                if (this.state.pendingScrollUpdateCount > 0) {
                    return;
                }
                this._viewabilityTuples.forEach((tuple)=>{
                    tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._listMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
                });
            }
        }
    ], [
        {
            key: "_findItemIndexWithKey",
            value: function _findItemIndexWithKey(props, key, hint) {
                var itemCount = props.getItemCount(props.data);
                if (hint != null && hint >= 0 && hint < itemCount) {
                    var curKey = VirtualizedList._getItemKey(props, hint);
                    if (curKey === key) {
                        return hint;
                    }
                }
                for(var ii = 0; ii < itemCount; ii++){
                    var curKey1 = VirtualizedList._getItemKey(props, ii);
                    if (curKey1 === key) {
                        return ii;
                    }
                }
                return null;
            }
        },
        {
            key: "_getItemKey",
            value: function _getItemKey(props, index) {
                var item = props.getItem(props.data, index);
                return VirtualizedList._keyExtractor(item, index, props);
            }
        },
        {
            key: "_createRenderMask",
            value: function _createRenderMask(props, cellsAroundViewport, additionalRegions) {
                var itemCount = props.getItemCount(props.data);
                (0, _invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, `Invalid cells around viewport "[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]" was passed to VirtualizedList._createRenderMask`);
                var renderMask = new _CellRenderMask.CellRenderMask(itemCount);
                if (itemCount > 0) {
                    var allRegions = [
                        cellsAroundViewport
                    ].concat(_to_consumable_array._(additionalRegions ?? []));
                    for (var region of allRegions){
                        renderMask.addCells(region);
                    }
                    // The initially rendered cells are retained as part of the
                    // "scroll-to-top" optimization
                    if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
                        var initialRegion = VirtualizedList._initialRenderRegion(props);
                        renderMask.addCells(initialRegion);
                    }
                    // The layout coordinates of sticker headers may be off-screen while the
                    // actual header is on-screen. Keep the most recent before the viewport
                    // rendered, even if its layout coordinates are not in viewport.
                    var stickyIndicesSet = new Set(props.stickyHeaderIndices);
                    VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
                }
                return renderMask;
            }
        },
        {
            key: "_initialRenderRegion",
            value: function _initialRenderRegion(props) {
                var itemCount = props.getItemCount(props.data);
                var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)));
                var lastCellIndex = Math.min(itemCount, firstCellIndex + (0, _VirtualizedListProps.initialNumToRenderOrDefault)(props.initialNumToRender)) - 1;
                return {
                    first: firstCellIndex,
                    last: lastCellIndex
                };
            }
        },
        {
            key: "_ensureClosestStickyHeader",
            value: function _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
                var stickyOffset = props.ListHeaderComponent ? 1 : 0;
                for(var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--){
                    if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
                        renderMask.addCells({
                            first: itemIdx,
                            last: itemIdx
                        });
                        break;
                    }
                }
            }
        },
        {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(newProps, prevState) {
                var _newProps_maintainVisibleContentPosition;
                // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
                // sure we're rendering a reasonable range here.
                var itemCount = newProps.getItemCount(newProps.data);
                if (itemCount === prevState.renderMask.numCells()) {
                    return prevState;
                }
                var maintainVisibleContentPositionAdjustment = null;
                var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
                var minIndexForVisible = ((_newProps_maintainVisibleContentPosition = newProps.maintainVisibleContentPosition) === null || _newProps_maintainVisibleContentPosition === void 0 ? void 0 : _newProps_maintainVisibleContentPosition.minIndexForVisible) ?? 0;
                var newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
                if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
                    if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
                        // Fast path if items were added at the start of the list.
                        var hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;
                        var firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);
                        maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;
                    } else {
                        maintainVisibleContentPositionAdjustment = null;
                    }
                }
                var constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {
                    first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,
                    last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment
                } : prevState.cellsAroundViewport, newProps);
                return {
                    cellsAroundViewport: constrainedCells,
                    renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
                    firstVisibleItemKey: newFirstVisibleItemKey,
                    pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount
                };
            }
        },
        {
            key: "_constrainToItemCount",
            value: function _constrainToItemCount(cells, props) {
                var itemCount = props.getItemCount(props.data);
                var lastPossibleCellIndex = itemCount - 1;
                // Constraining `last` may significantly shrink the window. Adjust `first`
                // to expand the window if the new `last` results in a new window smaller
                // than the number of cells rendered per batch.
                var maxToRenderPerBatch = (0, _VirtualizedListProps.maxToRenderPerBatchOrDefault)(props.maxToRenderPerBatch);
                var maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);
                return {
                    first: (0, _clamp.default)(0, cells.first, maxFirst),
                    last: Math.min(lastPossibleCellIndex, cells.last)
                };
            }
        },
        {
            key: "_keyExtractor",
            value: function _keyExtractor(item, index, props) {
                if (props.keyExtractor != null) {
                    return props.keyExtractor(item, index);
                }
                var key = (0, _VirtualizeUtils.keyExtractor)(item, index);
                if (key === String(index)) {
                    _usedIndexForKey = true;
                    if (item.type && item.type.displayName) {
                        _keylessItemComponentName = item.type.displayName;
                    }
                }
                return key;
            }
        }
    ]);
    return VirtualizedList;
}(_StateSafePureComponent.default);
VirtualizedList.contextType = _VirtualizedListContext.VirtualizedListContext;
var styles = _reactnative.StyleSheet.create({
    verticallyInverted: _reactnative.Platform.OS === 'android' ? {
        transform: [
            {
                scale: -1
            }
        ]
    } : {
        transform: [
            {
                scaleY: -1
            }
        ]
    },
    horizontallyInverted: {
        transform: [
            {
                scaleX: -1
            }
        ]
    },
    debug: {
        flex: 1
    },
    debugOverlayBase: {
        position: 'absolute',
        top: 0,
        right: 0
    },
    debugOverlay: {
        bottom: 0,
        width: 20,
        borderColor: 'blue',
        borderWidth: 1
    },
    debugOverlayFrame: {
        left: 0,
        backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
        left: 0,
        borderColor: 'green',
        borderWidth: 2
    },
    debugOverlayFrameVis: {
        left: 0,
        borderColor: 'red',
        borderWidth: 2
    }
});
module.exports = VirtualizedList;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js": 
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListCellRenderer.js ***!
  \*********************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return CellRenderer;
    }
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _VirtualizedListContext = __webpack_require__(/*! ./VirtualizedListContext.js */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
var _reactnative = __webpack_require__(/*! react-native */ "webpack/sharing/consume/default/react-native/react-native?36cc");
var CellRenderer = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(CellRenderer, _React_PureComponent);
    function CellRenderer() {
        _class_call_check._(this, CellRenderer);
        var _this;
        _this = _call_super._(this, CellRenderer, arguments), _this.state = {
            separatorProps: {
                highlighted: false,
                leadingItem: _this.props.item
            }
        }, // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
        // reused by SectionList and we can keep VirtualizedList simpler.
        // $FlowFixMe[missing-local-annot]
        _this._separators = {
            highlight: ()=>{
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    cellKey,
                    prevCellKey
                ], {
                    highlighted: true
                });
            },
            unhighlight: ()=>{
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    cellKey,
                    prevCellKey
                ], {
                    highlighted: false
                });
            },
            updateProps: (select, newProps)=>{
                var _this_props = _this.props, cellKey = _this_props.cellKey, prevCellKey = _this_props.prevCellKey;
                _this.props.onUpdateSeparators([
                    select === 'leading' ? prevCellKey : cellKey
                ], newProps);
            }
        }, _this._onLayout = (nativeEvent)=>{
            var _this_props_onCellLayout, _this_props;
            (_this_props_onCellLayout = (_this_props = _this.props).onCellLayout) === null || _this_props_onCellLayout === void 0 ? void 0 : _this_props_onCellLayout.call(_this_props, nativeEvent, _this.props.cellKey, _this.props.index);
        }, _this._onCellFocusCapture = (e)=>{
            var _this_props_onCellFocusCapture, _this_props;
            (_this_props_onCellFocusCapture = (_this_props = _this.props).onCellFocusCapture) === null || _this_props_onCellFocusCapture === void 0 ? void 0 : _this_props_onCellFocusCapture.call(_this_props, _this.props.cellKey);
        };
        return _this;
    }
    _create_class._(CellRenderer, [
        {
            key: "updateSeparatorProps",
            value: function updateSeparatorProps(newProps) {
                this.setState((state)=>({
                        separatorProps: _object_spread._({}, state.separatorProps, newProps)
                    }));
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                this.props.onUnmount(this.props.cellKey);
            }
        },
        {
            key: "_renderElement",
            value: function _renderElement(renderItem, ListItemComponent, item, index) {
                if (renderItem && ListItemComponent) {
                    console.warn('VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take' + ' precedence over renderItem.');
                }
                if (ListItemComponent) {
                    return /*#__PURE__*/ (0, _jsxruntime.jsx)(ListItemComponent, {
                        item: item,
                        index: index,
                        separators: this._separators
                    });
                }
                if (renderItem) {
                    return renderItem({
                        item,
                        index,
                        separators: this._separators
                    });
                }
                (0, _invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
            }
        },
        {
            key: "render",
            value: function render() {
                var _this_props = this.props, CellRendererComponent = _this_props.CellRendererComponent, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, ListItemComponent = _this_props.ListItemComponent, cellKey = _this_props.cellKey, horizontal = _this_props.horizontal, item = _this_props.item, index = _this_props.index, inversionStyle = _this_props.inversionStyle, onCellLayout = _this_props.onCellLayout, renderItem = _this_props.renderItem;
                var element = this._renderElement(renderItem, ListItemComponent, item, index);
                // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
                // called explicitly by `ScrollViewStickyHeader`.
                var itemSeparator = /*#__PURE__*/ _react.isValidElement(ItemSeparatorComponent) ? ItemSeparatorComponent : ItemSeparatorComponent && /*#__PURE__*/ (0, _jsxruntime.jsx)(ItemSeparatorComponent, _object_spread._({}, this.state.separatorProps));
                var cellStyle = inversionStyle ? horizontal ? [
                    styles.rowReverse,
                    inversionStyle
                ] : [
                    styles.columnReverse,
                    inversionStyle
                ] : horizontal ? [
                    styles.row,
                    inversionStyle
                ] : inversionStyle;
                var result = !CellRendererComponent ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_reactnative.View, _object_spread_props._(_object_spread._({
                    style: cellStyle,
                    onFocusCapture: this._onCellFocusCapture
                }, onCellLayout && {
                    onLayout: this._onLayout
                }), {
                    children: [
                        element,
                        itemSeparator
                    ]
                })) : /*#__PURE__*/ (0, _jsxruntime.jsxs)(CellRendererComponent, _object_spread_props._(_object_spread._({
                    cellKey: cellKey,
                    index: index,
                    item: item,
                    style: cellStyle,
                    onFocusCapture: this._onCellFocusCapture
                }, onCellLayout && {
                    onLayout: this._onLayout
                }), {
                    children: [
                        element,
                        itemSeparator
                    ]
                }));
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedListContext.VirtualizedListCellContextProvider, {
                    cellKey: this.props.cellKey,
                    children: result
                });
            }
        }
    ], [
        {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(props, prevState) {
                if (props.item !== prevState.separatorProps.leadingItem) {
                    return {
                        separatorProps: _object_spread_props._(_object_spread._({}, prevState.separatorProps), {
                            leadingItem: props.item
                        })
                    };
                }
                return null;
            }
        }
    ]);
    return CellRenderer;
}(_react.PureComponent);
var styles = _reactnative.StyleSheet.create({
    row: {
        flexDirection: 'row'
    },
    rowReverse: {
        flexDirection: 'row-reverse'
    },
    columnReverse: {
        flexDirection: 'column-reverse'
    }
});


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js": 
/*!****************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js ***!
  \****************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict-local
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get VirtualizedListCellContextProvider () {
        return VirtualizedListCellContextProvider;
    },
    get VirtualizedListContext () {
        return VirtualizedListContext;
    },
    get VirtualizedListContextProvider () {
        return VirtualizedListContextProvider;
    },
    get VirtualizedListContextResetter () {
        return VirtualizedListContextResetter;
    }
});
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
var VirtualizedListContext = /*#__PURE__*/ _react.createContext(null);
if (true) {
    VirtualizedListContext.displayName = 'VirtualizedListContext';
}
function VirtualizedListContextResetter(ref) {
    var children = ref.children;
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(VirtualizedListContext.Provider, {
        value: null,
        children: children
    });
}
function VirtualizedListContextProvider(ref) {
    var children = ref.children, value = ref.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(()=>({
            cellKey: null,
            getScrollMetrics: value.getScrollMetrics,
            horizontal: value.horizontal,
            getOutermostParentListRef: value.getOutermostParentListRef,
            registerAsNestedChild: value.registerAsNestedChild,
            unregisterAsNestedChild: value.unregisterAsNestedChild
        }), [
        value.getScrollMetrics,
        value.horizontal,
        value.getOutermostParentListRef,
        value.registerAsNestedChild,
        value.unregisterAsNestedChild
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(VirtualizedListContext.Provider, {
        value: context,
        children: children
    });
}
function VirtualizedListCellContextProvider(ref) {
    var cellKey = ref.cellKey, children = ref.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(()=>currContext == null ? null : _object_spread_props._(_object_spread._({}, currContext), {
            cellKey
        }), [
        currContext,
        cellKey
    ]);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(VirtualizedListContext.Provider, {
        value: context,
        children: children
    });
}


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js": 
/*!**************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListProps.js ***!
  \**************************************************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get horizontalOrDefault () {
        return horizontalOrDefault;
    },
    get initialNumToRenderOrDefault () {
        return initialNumToRenderOrDefault;
    },
    get maxToRenderPerBatchOrDefault () {
        return maxToRenderPerBatchOrDefault;
    },
    get onEndReachedThresholdOrDefault () {
        return onEndReachedThresholdOrDefault;
    },
    get onStartReachedThresholdOrDefault () {
        return onStartReachedThresholdOrDefault;
    },
    get windowSizeOrDefault () {
        return windowSizeOrDefault;
    }
});
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
function horizontalOrDefault(horizontal) {
    return horizontal ?? false;
}
function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender ?? 10;
}
function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch ?? 10;
}
function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold ?? 2;
}
function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold ?? 2;
}
function windowSizeOrDefault(windowSize) {
    return windowSize ?? 21;
}


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js": 
/*!****************************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js ***!
  \****************************************************************************************************************/
(function (module, exports, __webpack_require__) {
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *      
 * @format
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ "./node_modules/@swc/helpers/cjs/_interop_require_default.cjs");
var _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ "./node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ "./node_modules/@swc/helpers/cjs/_object_without_properties.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
var _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
var _VirtualizedList = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./VirtualizedList */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js"));
var _VirtualizeUtils = __webpack_require__(/*! ./VirtualizeUtils */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js");
var _invariant = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! invariant */ "./node_modules/invariant/browser.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react?3e43"));
/**
 * Right now this just flattens everything into one list and uses VirtualizedList under the
 * hood. The only operation that might not scale well is concatting the data arrays of all the
 * sections when new props are received, which should be plenty fast for up to ~10,000 items.
 */ var VirtualizedSectionList = /*#__PURE__*/ function(_React_PureComponent) {
    "use strict";
    _inherits._(VirtualizedSectionList, _React_PureComponent);
    function VirtualizedSectionList() {
        _class_call_check._(this, VirtualizedSectionList);
        var _this;
        _this = _call_super._(this, VirtualizedSectionList, arguments), // $FlowFixMe[missing-local-annot]
        _this._keyExtractor = (item, index)=>{
            var info = _this._subExtractor(index);
            return info && info.key || String(index);
        }, _this._convertViewable = (viewable)=>{
            (0, _invariant.default)(viewable.index != null, 'Received a broken ViewToken');
            var info = _this._subExtractor(viewable.index);
            if (!info) {
                return null;
            }
            var keyExtractorWithNullableIndex = info.section.keyExtractor;
            var keyExtractorWithNonNullableIndex = _this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
            var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, info.index ?? 0);
            return _object_spread_props._(_object_spread._({}, viewable), {
                index: info.index,
                key,
                section: info.section
            });
        }, _this._onViewableItemsChanged = (ref)=>{
            var viewableItems = ref.viewableItems, changed = ref.changed;
            var onViewableItemsChanged = _this.props.onViewableItemsChanged;
            if (onViewableItemsChanged != null) {
                onViewableItemsChanged({
                    viewableItems: viewableItems.map(_this._convertViewable, _this).filter(Boolean),
                    changed: changed.map(_this._convertViewable, _this).filter(Boolean)
                });
            }
        }, _this._renderItem = (listItemCount)=>// eslint-disable-next-line react/no-unstable-nested-components
            (ref)=>{
                var item = ref.item, index = ref.index;
                var info = _this._subExtractor(index);
                if (!info) {
                    return null;
                }
                var infoIndex = info.index;
                if (infoIndex == null) {
                    var section = info.section;
                    if (info.header === true) {
                        var renderSectionHeader = _this.props.renderSectionHeader;
                        return renderSectionHeader ? renderSectionHeader({
                            section
                        }) : null;
                    } else {
                        var renderSectionFooter = _this.props.renderSectionFooter;
                        return renderSectionFooter ? renderSectionFooter({
                            section
                        }) : null;
                    }
                } else {
                    var renderItem = info.section.renderItem || _this.props.renderItem;
                    var SeparatorComponent = _this._getSeparatorComponent(index, info, listItemCount);
                    (0, _invariant.default)(renderItem, 'no renderItem!');
                    return /*#__PURE__*/ (0, _jsxruntime.jsx)(ItemWithSeparator, {
                        SeparatorComponent: SeparatorComponent,
                        LeadingSeparatorComponent: infoIndex === 0 ? _this.props.SectionSeparatorComponent : undefined,
                        cellKey: info.key,
                        index: infoIndex,
                        item: item,
                        leadingItem: info.leadingItem,
                        leadingSection: info.leadingSection,
                        prevCellKey: (_this._subExtractor(index - 1) || {}).key,
                        // Callback to provide updateHighlight for this item
                        setSelfHighlightCallback: _this._setUpdateHighlightFor,
                        setSelfUpdatePropsCallback: _this._setUpdatePropsFor,
                        // Provide child ability to set highlight/updateProps for previous item using prevCellKey
                        updateHighlightFor: _this._updateHighlightFor,
                        updatePropsFor: _this._updatePropsFor,
                        renderItem: renderItem,
                        section: info.section,
                        trailingItem: info.trailingItem,
                        trailingSection: info.trailingSection,
                        inverted: !!_this.props.inverted
                    });
                }
            }, _this._updatePropsFor = (cellKey, value)=>{
            var updateProps = _this._updatePropsMap[cellKey];
            if (updateProps != null) {
                updateProps(value);
            }
        }, _this._updateHighlightFor = (cellKey, value)=>{
            var updateHighlight = _this._updateHighlightMap[cellKey];
            if (updateHighlight != null) {
                updateHighlight(value);
            }
        }, _this._setUpdateHighlightFor = (cellKey, updateHighlightFn)=>{
            if (updateHighlightFn != null) {
                _this._updateHighlightMap[cellKey] = updateHighlightFn;
            } else {
                // $FlowFixMe[prop-missing]
                delete _this._updateHighlightFor[cellKey];
            }
        }, _this._setUpdatePropsFor = (cellKey, updatePropsFn)=>{
            if (updatePropsFn != null) {
                _this._updatePropsMap[cellKey] = updatePropsFn;
            } else {
                delete _this._updatePropsMap[cellKey];
            }
        }, _this._updateHighlightMap = {}, _this._updatePropsMap = {}, _this._captureRef = (ref)=>{
            _this._listRef = ref;
        };
        return _this;
    }
    _create_class._(VirtualizedSectionList, [
        {
            key: "scrollToLocation",
            value: function scrollToLocation(params) {
                var index = params.itemIndex;
                for(var i = 0; i < params.sectionIndex; i++){
                    index += this.props.getItemCount(this.props.sections[i].data) + 2;
                }
                var viewOffset = params.viewOffset || 0;
                if (this._listRef == null) {
                    return;
                }
                var listRef = this._listRef;
                if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
                    var frame = listRef.__getListMetrics().getCellMetricsApprox(index - params.itemIndex, listRef.props);
                    viewOffset += frame.length;
                }
                var toIndexParams = _object_spread_props._(_object_spread._({}, params), {
                    viewOffset,
                    index
                });
                // $FlowFixMe[incompatible-use]
                this._listRef.scrollToIndex(toIndexParams);
            }
        },
        {
            key: "getListRef",
            value: function getListRef() {
                return this._listRef;
            }
        },
        {
            key: "render",
            value: function render() {
                var _this_props = this.props, ItemSeparatorComponent = _this_props.ItemSeparatorComponent, SectionSeparatorComponent = _this_props.SectionSeparatorComponent, _renderItem = _this_props.renderItem, renderSectionFooter = _this_props.renderSectionFooter, renderSectionHeader = _this_props.renderSectionHeader, _sections = _this_props.sections, stickySectionHeadersEnabled = _this_props.stickySectionHeadersEnabled, passThroughProps = _object_without_properties._(_this_props, [
                    "ItemSeparatorComponent",
                    "SectionSeparatorComponent",
                    "renderItem",
                    "renderSectionFooter",
                    "renderSectionHeader",
                    "sections",
                    "stickySectionHeadersEnabled"
                ]);
                var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
                var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
                var itemCount = 0;
                for (var section of this.props.sections){
                    // Track the section header indices
                    if (stickyHeaderIndices != null) {
                        stickyHeaderIndices.push(itemCount + listHeaderOffset);
                    }
                    // Add two for the section header and footer.
                    itemCount += 2;
                    itemCount += this.props.getItemCount(section.data);
                }
                var renderItem = this._renderItem(itemCount);
                return /*#__PURE__*/ (0, _jsxruntime.jsx)(_VirtualizedList.default, _object_spread_props._(_object_spread._({}, passThroughProps), {
                    keyExtractor: this._keyExtractor,
                    stickyHeaderIndices: stickyHeaderIndices,
                    renderItem: renderItem,
                    data: this.props.sections,
                    getItem: (sections, index)=>this._getItem(this.props, sections, index),
                    getItemCount: ()=>itemCount,
                    onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
                    ref: this._captureRef
                }));
            }
        },
        {
            key: "_getItem",
            value: function _getItem(props, sections, index) {
                if (!sections) {
                    return null;
                }
                var itemIdx = index - 1;
                for(var i = 0; i < sections.length; i++){
                    var section = sections[i];
                    var sectionData = section.data;
                    var itemCount = props.getItemCount(sectionData);
                    if (itemIdx === -1 || itemIdx === itemCount) {
                        // We intend for there to be overflow by one on both ends of the list.
                        // This will be for headers and footers. When returning a header or footer
                        // item the section itself is the item.
                        return section;
                    } else if (itemIdx < itemCount) {
                        // If we are in the bounds of the list's data then return the item.
                        return props.getItem(sectionData, itemIdx);
                    } else {
                        itemIdx -= itemCount + 2; // Add two for the header and footer
                    }
                }
                return null;
            }
        },
        {
            key: "_subExtractor",
            value: function _subExtractor(index) {
                var itemIndex = index;
                var _this_props = this.props, getItem = _this_props.getItem, getItemCount = _this_props.getItemCount, keyExtractor = _this_props.keyExtractor, sections = _this_props.sections;
                for(var i = 0; i < sections.length; i++){
                    var section = sections[i];
                    var sectionData = section.data;
                    var key = section.key || String(i);
                    itemIndex -= 1; // The section adds an item for the header
                    if (itemIndex >= getItemCount(sectionData) + 1) {
                        itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
                    } else if (itemIndex === -1) {
                        return {
                            section,
                            key: key + ':header',
                            index: null,
                            header: true,
                            trailingSection: sections[i + 1]
                        };
                    } else if (itemIndex === getItemCount(sectionData)) {
                        return {
                            section,
                            key: key + ':footer',
                            index: null,
                            header: false,
                            trailingSection: sections[i + 1]
                        };
                    } else {
                        var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
                        return {
                            section,
                            key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
                            index: itemIndex,
                            leadingItem: getItem(sectionData, itemIndex - 1),
                            leadingSection: sections[i - 1],
                            trailingItem: getItem(sectionData, itemIndex + 1),
                            trailingSection: sections[i + 1]
                        };
                    }
                }
            }
        },
        {
            key: "_getSeparatorComponent",
            value: function _getSeparatorComponent(index, info, listItemCount) {
                info = info || this._subExtractor(index);
                if (!info) {
                    return null;
                }
                var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
                var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
                var isLastItemInList = index === listItemCount - 1;
                var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
                if (SectionSeparatorComponent && isLastItemInSection) {
                    return SectionSeparatorComponent;
                }
                if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
                    return ItemSeparatorComponent;
                }
                return null;
            }
        }
    ]);
    return VirtualizedSectionList;
}(_react.PureComponent);
function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent, // this is the trailing separator and is associated with this item
    SeparatorComponent = props.SeparatorComponent, cellKey = props.cellKey, prevCellKey = props.prevCellKey, setSelfHighlightCallback = props.setSelfHighlightCallback, updateHighlightFor = props.updateHighlightFor, setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback, updatePropsFor = props.updatePropsFor, item = props.item, index = props.index, section = props.section, inverted = props.inverted;
    var _React_useState = _sliced_to_array._(_react.useState(false), 2), leadingSeparatorHiglighted = _React_useState[0], setLeadingSeparatorHighlighted = _React_useState[1];
    var _React_useState1 = _sliced_to_array._(_react.useState(false), 2), separatorHighlighted = _React_useState1[0], setSeparatorHighlighted = _React_useState1[1];
    var _React_useState2 = _sliced_to_array._(_react.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
    }), 2), leadingSeparatorProps = _React_useState2[0], setLeadingSeparatorProps = _React_useState2[1];
    var _React_useState3 = _sliced_to_array._(_react.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
    }), 2), separatorProps = _React_useState3[0], setSeparatorProps = _React_useState3[1];
    _react.useEffect(()=>{
        setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
        // $FlowFixMe[incompatible-call]
        setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
        return ()=>{
            setSelfUpdatePropsCallback(cellKey, null);
            setSelfHighlightCallback(cellKey, null);
        };
    }, [
        cellKey,
        setSelfHighlightCallback,
        setSeparatorProps,
        setSelfUpdatePropsCallback
    ]);
    var separators = {
        highlight: ()=>{
            setLeadingSeparatorHighlighted(true);
            setSeparatorHighlighted(true);
            if (prevCellKey != null) {
                updateHighlightFor(prevCellKey, true);
            }
        },
        unhighlight: ()=>{
            setLeadingSeparatorHighlighted(false);
            setSeparatorHighlighted(false);
            if (prevCellKey != null) {
                updateHighlightFor(prevCellKey, false);
            }
        },
        updateProps: (select, newProps)=>{
            if (select === 'leading') {
                if (LeadingSeparatorComponent != null) {
                    setLeadingSeparatorProps(_object_spread._({}, leadingSeparatorProps, newProps));
                } else if (prevCellKey != null) {
                    // update the previous item's separator
                    updatePropsFor(prevCellKey, _object_spread._({}, leadingSeparatorProps, newProps));
                }
            } else if (select === 'trailing' && SeparatorComponent != null) {
                setSeparatorProps(_object_spread._({}, separatorProps, newProps));
            }
        }
    };
    var element = props.renderItem({
        item,
        index,
        section,
        separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/ (0, _jsxruntime.jsx)(LeadingSeparatorComponent, _object_spread._({
        highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/ (0, _jsxruntime.jsx)(SeparatorComponent, _object_spread._({
        highlighted: separatorHighlighted
    }, separatorProps));
    var RenderSeparator = leadingSeparator || separator;
    var firstSeparator = inverted === false ? leadingSeparator : separator;
    var secondSeparator = inverted === false ? separator : leadingSeparator;
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            RenderSeparator ? firstSeparator : null,
            element,
            RenderSeparator ? secondSeparator : null
        ]
    });
}
module.exports = VirtualizedSectionList;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/clamp.js": 
/*!***************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/clamp.js ***!
  \***************************************************************************************************/
(function (module) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
function clamp(min, value, max) {
    if (value < min) {
        return min;
    }
    if (value > max) {
        return max;
    }
    return value;
}
module.exports = clamp;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/infoLog.js": 
/*!*****************************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/Utilities/infoLog.js ***!
  \*****************************************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *       strict
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ "./node_modules/@swc/helpers/cjs/_to_consumable_array.cjs");
/**
 * Intentional info-level logging for clear separation from ad-hoc console debug logging.
 */ function infoLog(...args) {
    var _console;
    return (_console = console).log.apply(_console, _to_consumable_array._(args));
}
module.exports = infoLog;


}),
"./node_modules/react-native/node_modules/@react-native/virtualized-lists/index.js": 
/*!*****************************************************************************************!*\
  !*** ./node_modules/react-native/node_modules/@react-native/virtualized-lists/index.js ***!
  \*****************************************************************************************/
(function (module, exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 *      
 */ 
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _VirtualizeUtils = __webpack_require__(/*! ./Lists/VirtualizeUtils */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizeUtils.js");
module.exports = {
    keyExtractor: _VirtualizeUtils.keyExtractor,
    get VirtualizedList () {
        return __webpack_require__(/*! ./Lists/VirtualizedList */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js");
    },
    get VirtualizedSectionList () {
        return __webpack_require__(/*! ./Lists/VirtualizedSectionList */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedSectionList.js");
    },
    get VirtualizedListContextResetter () {
        var VirtualizedListContext = __webpack_require__(/*! ./Lists/VirtualizedListContext */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/VirtualizedListContext.js");
        return VirtualizedListContext.VirtualizedListContextResetter;
    },
    get ViewabilityHelper () {
        return __webpack_require__(/*! ./Lists/ViewabilityHelper */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/ViewabilityHelper.js");
    },
    get FillRateHelper () {
        return __webpack_require__(/*! ./Lists/FillRateHelper */ "./node_modules/react-native/node_modules/@react-native/virtualized-lists/Lists/FillRateHelper.js");
    }
};


}),

}]);//# sourceMappingURL=vendors-node_modules_react-native_node_modules_react-native_virtualized-lists_index_js.chunk.bundle.map?platform=android